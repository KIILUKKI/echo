<!DOCTYPE html>
<html lang="fi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Echo</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
<link rel="icon" type="image/png" sizes="512x512" href="images/echo_space_favicon.png">


<style>
 :root{
    --bg:#0b0f14;
    --panel:#161b22;
    --muted:#8b949e;
    --accent:#7700ff;
    --card:#21262d;
    --text:#e6edf3;
    --lobby-width:260px;
    --drawer-duration:200ms;
    --drawer-ease:cubic-bezier(.16,.84,.24,1);
    --guest-gray:#9aa0a6;
  }
  @font-face{font-family:'Clock Classic';src:url(fonts/Clock-Classic.ttf) format('truetype');font-weight:normal;font-style:normal}
  *,#app,html,body{box-sizing:border-box;margin:0}
 html,body{height:100%;background:var(--bg);color:var(--text);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
 #app{width:100%;height:100%;position:relative;overflow:hidden}

  /* Top Controls */
  #topRightControls{position:fixed;top:12px;right:12px;display:flex;gap:10px;align-items:center;z-index:120;pointer-events:auto}
  #howBtn,#fullBtn,#settingsBtn,#profileBtn,#openDMPanel{background:transparent;border:0;color:var(--text);font-size:14px;padding:8px 12px;border-radius:10px;cursor:pointer;display:inline-flex;align-items:center;gap:8px;min-height:40px;min-width:40px;justify-content:center;box-shadow:0 6px 18px rgba(0,0,0,.15)}
  #howBtn:hover,#fullBtn:hover,#settingsBtn:hover,#profileBtn:hover,#openDMPanel:hover{background:rgba(255,255,255,.02)}
  #fullBtn{font-size:15px;padding:10px 14px;border-radius:12px;font-weight:600}
  #profileBtn{font-weight:500}

 /* Menus */
 .settings-menu,.how-menu{position:fixed;top:56px;right:12px;background:var(--panel);border:1px solid #0d1117;border-radius:10px;box-shadow:0 6px 20px rgba(0,0,0,.6);z-index:119;display:none}
 .settings-menu.show,.how-menu.show{display:block}
 .settings-menu button{display:block;width:100%;padding:8px 12px;background:transparent;border:0;color:var(--text);text-align:left;border-radius:8px;cursor:pointer}
 .settings-menu button:hover,#settingsNotifications:hover{background:rgba(255,255,255,.03)}
 .how-menu{width:360px;max-height:60vh;padding:12px;z-index:121;overflow:auto}
 .how-menu h3{margin:0 0 8px;font-size:15px}
 .how-menu .section{margin-bottom:10px;font-size:13px;color:var(--muted)}
 .how-menu .section b{color:var(--text)}
 .how-menu .close-how{display:block;margin-top:8px;padding:8px;border-radius:8px;background:transparent;border:0;color:var(--text);cursor:pointer;text-align:right}
 .how-menu .close-how:hover{background:rgba(255,255,255,.02)}

 /* Profile Card */
 .profile-card{position:fixed;top:56px;right:12px;background:var(--panel);border:1px solid #0d1117;padding:12px;border-radius:10px;box-shadow:0 6px 20px rgba(0,0,0,.6);display:none;z-index:118;width:220px}
 .profile-card.show{display:block}
 .profile-card .row{display:flex;justify-content:space-between;margin-bottom:6px}

  /* Login */
  #login{position:absolute;inset:0;display:flex;flex-direction:column;justify-content:center;align-items:center;gap:10px;background:var(--bg);z-index:30;padding:20px}
  #login input{padding:12px;border-radius:10px;border:0;background:var(--card);color:var(--text);width:100%;max-width:360px}
  #login button{padding:12px 18px;border:0;border-radius:10px;background:var(--accent);color:#000;font-weight:700;cursor:pointer;max-width:360px;width:100%;margin-top:4px}
  #login .small{background:transparent;border:1px solid #333;padding:8px;border-radius:8px;color:var(--muted);cursor:pointer}
  #loginMsg{margin-top:10px;font-size:13px;color:var(--muted);min-height:18px}

  /* Auth Tabs */
  .auth-tabs{display:flex;gap:8px;margin-bottom:16px;width:100%;max-width:360px}
  .auth-tab{flex:1;padding:12px;border:0;border-radius:10px;background:transparent;color:var(--muted);font-weight:600;cursor:pointer;transition:all 200ms}
  .auth-tab:hover{background:rgba(255,255,255,.03)}
  .auth-tab.active{background:var(--card);color:var(--text)}
  .auth-panel{width:100%;max-width:360px;display:none;flex-direction:column;gap:10px}
  .auth-panel.active{display:flex}

 /* App Layout */
 #home,#main{position:absolute;inset:0;display:none}
 #home{display:flex;flex-direction:row}

 /* Lobby */
 #homeLeft{width:var(--lobby-width);min-width:120px;background:var(--panel);padding:12px;border-right:1px solid #0d1117;height:100%;overflow:auto;transition:width 200ms ease,transform 220ms cubic-bezier(.2,.9,.3,1);position:relative}
 #homeLeft.collapsed{width:40px;padding:8px}
 #lobbyHeader{display:flex;align-items:center;gap:8px;margin-bottom:10px}
 #lobbyTitle{flex:1;font-weight:700}
 .room{padding:10px 12px;border-radius:10px;background:var(--card);margin-bottom:8px;cursor:pointer;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
 .room:hover{background:var(--accent);color:#000}
 #lobbyControls{display:flex;gap:6px;align-items:center;margin-bottom:8px}
 .iconbtn{background:transparent;border:0;color:var(--text);padding:6px;border-radius:8px;cursor:pointer}
 .iconbtn:active{transform:scale(.98)}
 #lobbySizeBtn{font-weight:700;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,.03)}

 /* Home Center */
 #homeCenter{flex:1;display:flex;flex-direction:column;justify-content:center;align-items:center;position:relative;padding:18px;overflow:hidden}
 #homeCenter::before{content:"";position:absolute;inset:0;z-index:0;background:url(images/lobby_bg.jpg) center/cover no-repeat fixed;pointer-events:none}
  #homeLogo{position:absolute;top:-50px;left:48%;transform:translateX(-50%);width:80%;max-width:920px;z-index:2;pointer-events:none}
  #clockWidget{position:absolute;top:-42px;left:calc(48% - 200px);font-family:'Clock Classic',Clock-Classic,Inter,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial,sans-serif;font-size:42px;font-weight:300;color:var(--text);z-index:3;pointer-events:none;text-shadow:0 2px 10px rgba(0,0,0,.5);letter-spacing:2px}
  #homeCenter>*:not(#homeLogo){position:relative;z-index:1}

 /* Buttons */
 .createRoom{padding:14px 28px;border-radius:12px;background:var(--accent);color:#000;border:0;font-weight:700;cursor:pointer;z-index:10;box-shadow:0 4px 15px rgba(0,0,0,.3);white-space:nowrap;margin-top:200px}
 .createRoom:hover{transform:scale(1.05);box-shadow:0 6px 20px rgba(0,0,0,.4)}
 .nickColorBtn{padding:10px 20px;border-radius:12px;background:transparent;color:var(--text);border:1px solid var(--accent);font-weight:600;cursor:pointer;z-index:10;font-size:14px;white-space:nowrap;margin-top:15px}
  .nickColorBtn:hover{background:var(--accent);color:#000;transform:scale(1.05)}
  #startDmBtn{color:#845ef7 !important}
  #startDmBtn:hover{background:#845ef7 !important;color:#000 !important;transform:scale(1.05)}
  #startDmBtn:active{transform:scale(0.98)}
  #nickColorBtn:hover{color:#000 !important}

 /* Main Chat */
 #main{display:flex;flex-direction:column}
 #header{height:56px;background:var(--panel);display:flex;align-items:center;padding:8px 12px;border-bottom:1px solid #0d1117;position:relative;z-index:100}
 #header .left{display:flex;align-items:center;gap:8px}
 #roomName{font-weight:700}
 #chatWrapper{display:flex;flex:1;overflow:hidden;min-height:0;position:relative}
 #chatSidebar{width:var(--lobby-width);background:var(--panel);border-right:1px solid #0d1117;padding:8px;overflow:auto;transition:width 200ms ease}
 #chatSidebar.collapsed{width:40px;padding:6px}
 #chatWrapperMain{flex:1;display:flex;flex-direction:column;min-height:0;position:relative}
 #chat{flex:1;padding:16px;overflow-y:auto;display:flex;flex-direction:column;gap:10px;background:linear-gradient(180deg,transparent,rgba(255,255,255,.01));transition:padding-bottom 120ms ease}
 .message{display:flex;gap:10px;align-items:flex-start;transition:transform 160ms ease}
 .avatar{width:40px;height:40px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;color:#000}
 .msg{background:var(--panel);padding:10px 96px 10px 14px;border-radius:12px;position:relative;max-width:70%}
 .msg-text{white-space:pre-wrap;word-break:break-word;overflow-wrap:anywhere;max-width:100%}
 .time{font-size:11px;color:var(--muted);margin-left:6px}
 .reply-btn{position:absolute;right:52px;top:8px;font-size:12px;color:var(--muted);cursor:pointer;opacity:0}
 .msg:hover .reply-btn{opacity:1}
 .reply-preview{background:rgba(255,255,255,.02);border-left:3px solid var(--accent);padding:6px;font-size:13px;margin-bottom:8px;border-radius:6px;max-width:calc(100% - 96px);cursor:pointer;transition:background 150ms}
 .reply-preview:hover{background:rgba(255,255,255,.05)}
 .edited-note{font-size:12px;color:var(--muted);margin-left:8px;display:inline-block}

 /* Reactions */
 .reactions-container{display:inline-flex;gap:3px;align-items:center;margin-left:8px;vertical-align:middle}
 .reaction-btn{background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.06);border-radius:10px;padding:1px 5px;font-size:11px;cursor:pointer;transition:all 120ms ease;display:inline-flex;align-items:center;gap:2px;user-select:none;line-height:1}
 .reaction-btn:hover{background:rgba(255,255,255,.06);border-color:rgba(255,255,255,.12);transform:scale(1.05)}
 .reaction-btn.active{background:rgba(88,166,255,.12);border-color:rgba(88,166,255,.3)}
 .reaction-btn .emoji{font-size:12px}
 .reaction-btn .count{font-size:10px;color:var(--muted);font-weight:500;min-width:10px;text-align:center}
 .reaction-btn.active .count{color:var(--accent)}
 .add-reaction-btn{background:transparent;border:1px solid rgba(255,255,255,.08);border-radius:8px;padding:1px 4px;font-size:10px;cursor:pointer;transition:all 120ms ease;color:var(--muted);opacity:.4;display:inline-flex;align-items:center;line-height:1;font-weight:500}
 .add-reaction-btn:hover{opacity:1;background:rgba(255,255,255,.06);border-color:rgba(255,255,255,.18);color:var(--text);transform:scale(1.1)}

 /* Reaction Picker */
 .reaction-picker{display:none;position:fixed;background:var(--card);border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:0;z-index:1000;box-shadow:0 10px 30px rgba(0,0,0,.5);flex-direction:column;max-width:280px;overflow:hidden}
 .reaction-picker.show{display:flex}
 .reaction-picker-header{padding:10px 12px 8px;border-bottom:1px solid rgba(255,255,255,.06);background:rgba(255,255,255,.02)}
 .reaction-picker-header span{font-size:12px;color:var(--muted);font-weight:500;text-transform:uppercase;letter-spacing:.5px}
 .reaction-picker-grid{display:grid;grid-template-columns:repeat(5,1fr);gap:4px;padding:10px;max-height:200px;overflow-y:auto}
 .reaction-picker .emoji-option{cursor:pointer;font-size:22px;padding:6px;border-radius:8px;transition:all 150ms ease;display:flex;align-items:center;justify-content:center;height:36px;width:36px}
 .reaction-picker .emoji-option:hover{background:rgba(88,166,255,.15);transform:scale(1.15)}

 /* GIF */
 .gif-container{margin-top:6px;border-radius:10px;overflow:hidden;max-width:300px;background:rgba(255,255,255,.03);cursor:pointer;transition:transform 150ms ease}
 .gif-container:hover{transform:scale(1.01)}
 .gif-container img{width:100%;height:auto;display:block;border-radius:10px}

 /* Typing Indicator */
 #typingIndicator{position:relative;padding:8px 12px;margin:0 12px 8px;border-radius:12px;background:linear-gradient(90deg,rgba(255,255,255,.015),rgba(255,255,255,.01));border:1px solid rgba(255,255,255,.02);color:var(--muted);font-size:13px;align-items:center;gap:10px;z-index:90;transition:opacity 180ms ease,transform 180ms ease;display:flex}
 .typing-avatars{display:flex;gap:6px;align-items:center}
 .typing-avatars .typ-av{width:28px;height:28px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;color:#000;border:2px solid rgba(255,255,255,.04);font-size:12px;background:var(--guest-gray);box-shadow:0 6px 18px rgba(0,0,0,.35)}
 .typing-text{display:flex;flex-direction:row;align-items:center;gap:8px;color:var(--muted);font-size:13px}
 .typing-dots{display:inline-flex;gap:6px;align-items:flex-end;height:14px}
 .typing-dots span{width:6px;height:6px;border-radius:50%;display:inline-block;background:var(--muted);opacity:.45;transform:translateY(0);animation:typing-bounce 1s infinite}
 .typing-dots span:nth-child(1){animation-delay:0s}
 .typing-dots span:nth-child(2){animation-delay:.12s}
 .typing-dots span:nth-child(3){animation-delay:.24s}
 @keyframes typing-bounce{0%,100%{transform:translateY(0);opacity:.45}40%{transform:translateY(-6px);opacity:1}80%{transform:translateY(0);opacity:.45}}
 @media(max-width:480px){.typing-avatars .typ-av{width:24px;height:24px;font-size:11px}#typingIndicator{margin:0 10px 8px;padding:8px;border-radius:10px}#replyBox{bottom:72px;width:calc(100% - 24px)}}

 /* Reply Box */
 #replyBox{display:none;position:fixed;left:50%;transform:translateX(-50%);bottom:86px;width:calc(100% - 36px);max-width:920px;background:var(--card);padding:8px 14px;font-size:13px;color:var(--text);border-radius:10px;z-index:999;box-shadow:0 8px 26px rgba(0,0,0,.45)}
 #inputBar{padding:12px;background:var(--panel);border-top:1px solid #0d1117;display:flex;gap:8px;align-items:center;position:relative;z-index:80}
 #msg{flex:1;padding:12px;border-radius:10px;border:0;background:var(--card);color:var(--text)}

 /* Emoji Picker */
 #emojiPicker{display:none;flex-direction:column;gap:8px;padding:10px;background:var(--card);border-radius:12px;position:absolute;bottom:72px;left:12px;width:280px;max-height:340px;overflow:hidden;box-shadow:0 8px 32px rgba(0,0,0,.5);border:1px solid rgba(255,255,255,.08);z-index:100}
 #emojiPicker.show{display:flex}
 #emojiPicker .emoji-tabs{display:flex;gap:4px;margin-bottom:8px;padding-bottom:8px;border-bottom:1px solid rgba(255,255,255,.08);overflow-x:auto;scrollbar-width:none;-ms-overflow-style:none;flex-shrink:0}
 #emojiPicker .emoji-tabs::-webkit-scrollbar{display:none}
 #emojiPicker .emoji-tab{background:transparent;border:1px solid transparent;color:var(--muted);padding:4px 8px;border-radius:6px;cursor:pointer;font-size:16px;min-width:32px;height:32px;transition:all 150ms ease;display:flex;align-items:center;justify-content:center;flex-shrink:0}
 #emojiPicker .emoji-tab:hover{background:rgba(255,255,255,.05);border-color:rgba(255,255,255,.1);color:var(--text)}
 #emojiPicker .emoji-tab.active{background:rgba(88,166,255,.2);border-color:rgba(88,166,255,.3);color:var(--accent)}
 #emojiPicker>div:nth-child(2){display:grid;grid-template-columns:repeat(7,1fr);gap:3px;max-height:200px;overflow-y:auto;overflow-x:hidden;padding-right:4px}
 #emojiPicker .emoji-item{cursor:pointer;font-size:20px;padding:4px;border-radius:6px;text-align:center;transition:all 120ms ease;display:flex;align-items:center;justify-content:center;height:32px;width:32px}
 #emojiPicker .emoji-item:hover{background:rgba(88,166,255,.15);transform:scale(1.1)}
 #emojiPicker input[type="text"]{width:100%;padding:6px 10px;margin-top:6px;border-radius:6px;border:1px solid rgba(255,255,255,.1);background:rgba(255,255,255,.03);color:var(--text);font-size:13px;box-sizing:border-box;outline:none;transition:all 150ms ease;flex-shrink:0}
 #emojiPicker input[type="text"]:focus{border-color:rgba(88,166,255,.4);background:rgba(255,255,255,.05)}
 #emojiBtn{background:linear-gradient(180deg,rgba(88,166,255,.1),rgba(88,166,255,.03));border:1px solid rgba(88,166,255,.1);padding:6px;border-radius:10px;width:44px;height:44px;display:flex;align-items:center;justify-content:center;font-size:18px;cursor:pointer;box-shadow:0 6px 18px rgba(0,0,0,.45);color:var(--accent)}
 #emojiBtn:active{transform:scale(.98)}
 .emoji-icon{font-size:18px;line-height:1;transform:translateY(1px)}

 /* GIF Picker */
 #gifBtn{background:linear-gradient(180deg,rgba(88,166,255,.1),rgba(88,166,255,.03));border:1px solid rgba(88,166,255,.25);color:var(--accent);padding:8px 12px;border-radius:10px;cursor:pointer;font-size:12px;font-weight:700;transition:all 200ms ease;display:flex;align-items:center;gap:4px}
 #gifBtn:hover{background:linear-gradient(180deg,rgba(88,166,255,.18),rgba(88,166,255,.06));border-color:rgba(88,166,255,.4);box-shadow:0 6px 18px rgba(0,0,0,.45);color:var(--accent)}
 #gifBtn:active{transform:scale(.98)}
 #gifPicker{display:none;flex-direction:column;gap:8px;padding:10px;background:var(--card);border-radius:12px;position:absolute;bottom:72px;left:12px;width:320px;max-height:360px;z-index:100;box-shadow:0 8px 32px rgba(0,0,0,.5);border:1px solid rgba(255,255,255,.08);overflow:hidden}
 #gifPicker.show{display:flex}
 #gifSearch{width:100%;padding:8px 12px;border-radius:8px;border:1px solid rgba(255,255,255,.1);background:rgba(255,255,255,.03);color:var(--text);font-size:14px;box-sizing:border-box;outline:none;transition:all 150ms ease;flex-shrink:0}
 #gifSearch:focus{border-color:rgba(88,166,255,.4);background:rgba(255,255,255,.05)}
 #gifResults{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;overflow-y:auto;overflow-x:hidden;max-height:200px;padding-right:4px;flex:1}
 #gifResults::-webkit-scrollbar{width:6px}
 #gifResults::-webkit-scrollbar-track{background:transparent}
 #gifResults::-webkit-scrollbar-thumb{background:rgba(255,255,255,.1);border-radius:3px}
 .gif-item{position:relative;width:100%;height:80px;border-radius:10px;overflow:hidden;cursor:pointer;background:rgba(255,255,255,.03);transition:all 150ms ease;border:1px solid rgba(255,255,255,.05)}
 .gif-item:hover{transform:scale(1.03);border-color:rgba(88,166,255,.3);box-shadow:0 4px 12px rgba(88,166,255,.15)}
 .gif-item img{width:100%;height:100%;object-fit:cover;transition:transform 200ms ease;display:block}
 .gif-item:hover img{transform:scale(1.05)}
 .gif-loading{display:flex;align-items:center;justify-content:center;color:var(--muted);font-size:12px}
 .gif-item::after{content:"";position:absolute;inset:0;background:rgba(88,166,255,0);pointer-events:none;transition:background 150ms ease}
 .gif-item:hover::after{background:rgba(88,166,255,.1)}
 .gif-tabs{display:flex;gap:4px;margin-bottom:6px;padding-bottom:6px;border-bottom:1px solid rgba(255,255,255,.08);overflow-x:auto;scrollbar-width:none;flex-shrink:0}
 .gif-tabs::-webkit-scrollbar{display:none}
 .gif-tab{background:transparent;border:1px solid transparent;color:var(--muted);padding:4px 8px;border-radius:6px;cursor:pointer;font-size:11px;font-weight:500;transition:all 150ms ease;white-space:nowrap;flex-shrink:0}
 .gif-tab:hover{background:rgba(255,255,255,.05);border-color:rgba(255,255,255,.1);color:var(--text)}
 .gif-tab.active{background:rgba(88,166,255,.2);border-color:rgba(88,166,255,.3);color:var(--accent)}

 /* More Button */
 .more-btn{position:absolute;right:12px;top:8px;font-size:16px;color:var(--muted);cursor:pointer;opacity:0;padding:4px;border-radius:6px;z-index:12;transform:none}
 .msg:hover .more-btn{opacity:1}

 /* Mobile */
 .mobile-overlay{position:fixed;inset:0;background:rgba(0,0,0,0);z-index:40;display:none;transition:background var(--drawer-duration) var(--drawer-ease)}
 .mobile-overlay.show{display:block;background:rgba(0,0,0,.45)}
 .mobile-lobby-drawer{position:fixed;left:0;top:0;height:100%;width:80%;max-width:340px;background:var(--panel);z-index:50;padding:12px;transform:translateX(-110%);transition:transform var(--drawer-duration) var(--drawer-ease),opacity calc(var(--drawer-duration)*.9) var(--drawer-ease);opacity:0;will-change:transform}
 .mobile-lobby-drawer.show{transform:translateX(0);opacity:1}
 #openLobbyBtn{position:fixed;left:12px;bottom:12px;background:var(--accent);border:none;padding:12px;border-radius:999px;z-index:60;font-weight:800;color:#000;cursor:pointer;box-shadow:0 6px 18px rgba(0,0,0,.5)}
 #scrollBottomBtn{position:fixed;left:50%;transform:translateX(-50%);bottom:86px;background:var(--accent);border:none;padding:10px;border-radius:999px;z-index:99;font-weight:800;color:#000;cursor:pointer;box-shadow:0 6px 18px rgba(0,0,0,.4);display:none}
 .tooltip{position:fixed;padding:6px 8px;background:var(--panel);border:1px solid #0d1117;border-radius:8px;font-size:13px;color:var(--muted);z-index:120;display:none}
 .context-menu{position:fixed;background:var(--panel);border:1px solid #0d1117;padding:6px;border-radius:8px;box-shadow:0 8px 24px rgba(0,0,0,.6);display:none;z-index:130}
 .context-menu button{display:block;padding:8px 10px;border:0;background:transparent;color:var(--text);text-align:left;width:160px;border-radius:6px;cursor:pointer}
 .context-menu button:hover{background:rgba(255,255,255,.03)}
 #chat::-webkit-scrollbar,#homeLeft::-webkit-scrollbar,#chatSidebar::-webkit-scrollbar{height:8px;width:8px}
 #chat::-webkit-scrollbar-thumb,#homeLeft::-webkit-scrollbar-thumb,#chatSidebar::-webkit-scrollbar-thumb{background:rgba(255,255,255,.06);border-radius:999px}
 #chat,#homeLeft,#chatSidebar{scrollbar-color:rgba(255,255,255,.06) transparent;scrollbar-width:thin}
  #onlineUsersDrawer.show{transform:translateX(0)}

  .online-user{display:flex;align-items:center;gap:8px;padding:8px;border-radius:8px;margin-bottom:4px;cursor:pointer;transition:background 150ms}
  .online-user:hover{background:rgba(255,255,255,0.03)}
  .dm-action-btn{flex-shrink:0;padding:6px 10px;border-radius:6px;border:0;background:var(--accent);color:#000;font-weight:700;cursor:pointer;font-size:14px;display:flex;align-items:center;justify-content:center;opacity:0;transition:all 150ms;visibility:hidden}
  .online-user:hover .dm-action-btn{opacity:1;visibility:visible}

  /* DM Panel */
  #dmPanel.show{transform:translateX(0)}
  #dmPanel .online-user{display:flex;align-items:center;gap:10px;padding:8px;border-radius:8px;margin-bottom:4px;cursor:pointer;transition:background 150ms}
  #dmPanel .online-user:hover{background:rgba(255,255,255,0.03)}
  #dmPanel .dm-conv{display:flex;align-items:center;gap:12px;padding:12px;border-radius:12px;margin-bottom:6px;cursor:pointer;transition:all 150ms;background:var(--card)}
  #dmPanel .dm-conv:hover{background:rgba(255,255,255,0.06);transform:translateX(4px)}
  #dmPanel .dm-conv-avatar{width:44px;height:44px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;color:#000;font-size:16px;flex-shrink:0}
  #dmPanel .dm-conv-info{flex:1;min-width:0}
  #dmPanel .dm-conv-name{font-weight:600;font-size:14px;margin-bottom:2px}
  #dmPanel .dm-conv-preview{font-size:12px;color:var(--muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  #dmPanel .dm-conv-time{font-size:11px;color:var(--muted)}
  #dmPanel .dm-conv-unread{background:var(--accent);color:#000;font-size:10px;padding:2px 7px;border-radius:10px;font-weight:700}
  .dm-tab{border-bottom:2px solid transparent;transition:all 150ms}
  .dm-tab.active{border-bottom-color:var(--accent);color:var(--text)}
  .dm-tab:hover:not(.active){color:var(--text)}
  #dmEmptyState{display:block}

  /* DM Chat Panel */
  #dmMessages{background:linear-gradient(180deg,transparent,rgba(255,255,255,.01))}
  #dmMessages::-webkit-scrollbar,#dmConversations::-webkit-scrollbar,#dmAllUsers::-webkit-scrollbar{height:8px;width:8px}
  #dmMessages::-webkit-scrollbar-thumb,#dmConversations::-webkit-scrollbar-thumb,#dmAllUsers::-webkit-scrollbar-thumb{background:rgba(255,255,255,.06);border-radius:999px}
  #dmMessages::-webkit-scrollbar-track,#dmConversations::-webkit-scrollbar-track,#dmAllUsers::-webkit-scrollbar-track{background:transparent}
  #dmInput:focus{outline:none;box-shadow:0 0 0 2px var(--accent)}
 .online-user{display:flex;align-items:center;gap:8px;padding:8px;border-radius:8px;margin-bottom:4px;cursor:pointer;transition:background 150ms}
.online-user:hover{background:rgba(255,255,255,0.03)}
.online-user:hover .dm-action-btn{opacity:1}
 .online-user:hover{background:rgba(255,255,255,.03)}
 .online-user-avatar{width:32px;height:32px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:14px;color:#000}
 .online-user-info{flex:1;min-width:0}
 .online-user-name{font-size:13px;font-weight:500;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
 .online-user-status{font-size:11px;color:var(--muted);display:flex;align-items:center;gap:4px}
 .online-indicator{width:8px;height:8px;border-radius:50%;background:#3fb950}
 .offline-indicator{width:8px;height:8px;border-radius:50%;background:var(--muted)}

 /* Modal Styles */
 .modal{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:var(--panel);padding:20px;border-radius:12px;z-index:200;box-shadow:0 10px 40px rgba(0,0,0,.6)}
 .modal input,.modal textarea{width:100%;margin-bottom:10px;padding:10px;border-radius:8px;border:0;background:var(--card);color:var(--text);font-family:inherit;box-sizing:border-box}
 .modal textarea{min-height:100px;resize:vertical}
 .modal h3{margin-top:0;margin-bottom:15px}
 .modal-btns{display:flex;gap:10px;justify-content:flex-end}
 .modal-btn{padding:8px 16px;border-radius:8px;border:none;cursor:pointer;font-weight:600}
 .modal-btn-cancel{background:transparent;color:var(--muted)}
 .modal-btn-confirm{background:var(--accent);color:#000}
 .modal-msg{margin-top:10px;font-size:13px;color:var(--muted)}

 /* Color Grid */
 .color-grid{display:grid;grid-template-columns:repeat(5,1fr);gap:8px;margin:15px 0}
 .color-option{width:40px;height:40px;border-radius:50%;cursor:pointer;border:2px solid transparent}
 .color-option:hover{border-color:var(--accent);transform:scale(1.1)}

 /* Profile Card */
 .profile-row{display:flex;justify-content:space-between;margin-bottom:6px}
 .profile-row>div:first-child{color:var(--muted)}

 /* Sidebar */
 .sidebar-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;font-weight:700}
 .online-users-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;font-weight:700;font-size:14px}

 /* Mobile Drawer */
 .drawer-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;font-weight:700}

</style>
</head>
<body>
<div id="app">

  <!-- TOP-RIGHT CONTROLS CONTAINER -->
  <div id="topRightControls" aria-hidden="false">
    <!-- Profile button -->
    <button id="profileBtn" title="Profile">Profile</button>
    <!-- HOW TO button -->
    <button id="howBtn" title="How To">How To</button>
    <!-- FULLSCREEN button -->
    <button id="fullBtn" title="Toggle fullscreen" aria-label="Fullscreen">â¤¢</button>
    <!-- SETTINGS GEAR -->
    <button id="settingsBtn" title="Settings">âš™ï¸</button>
  </div>

  <div id="settingsMenu" class="settings-menu" aria-hidden="true">
    <button id="settingsChangeUsername">Change Username</button>
    <button id="settingsChangePassword">Change Password</button>
    <label id="settingsNotifications" style="display:flex;align-items:center;gap:8px;padding:8px 12px;cursor:pointer;border-radius:8px;transition:background 150ms;margin:0;font-size:14px;">
      <input type="checkbox" id="notificationsToggle" style="cursor:pointer">
      <span>Enable Notifications</span>
    </label>
    <button id="settingsLogout">Logout</button>
    <button id="settingsDelete">Delete user</button>
    <button id="settingsSuperAdmin" style="color:#ff6b6b;border-top:1px solid rgba(255,255,255,0.1);margin-top:4px;padding-top:10px">âš ï¸ Super Admin</button>
  </div>

  <!-- Change Username Modal -->
  <div id="changeUsernameModal" class="modal" style="display:none;min-width:300px">
    <h3>Change Username</h3>
    <input id="newUsername" placeholder="New username">
    <input id="currentPasswordForUsername" type="password" placeholder="Current password" style="margin-bottom:15px">
    <div class="modal-btns">
      <button id="cancelChangeUsername" class="modal-btn modal-btn-cancel">Cancel</button>
      <button id="confirmChangeUsername" class="modal-btn modal-btn-confirm">Change</button>
    </div>
    <div id="changeUsernameMsg" class="modal-msg"></div>
  </div>

  <!-- Change Password Modal -->
  <div id="changePasswordModal" class="modal" style="display:none;min-width:300px">
    <h3>Change Password</h3>
    <input id="currentPassword" type="password" placeholder="Current password">
    <input id="newPassword" type="password" placeholder="New password">
    <input id="confirmNewPassword" type="password" placeholder="Confirm new password" style="margin-bottom:15px">
    <div class="modal-btns">
      <button id="cancelChangePassword" class="modal-btn modal-btn-cancel">Cancel</button>
      <button id="confirmChangePassword" class="modal-btn modal-btn-confirm">Change</button>
    </div>
    <div id="changePasswordMsg" class="modal-msg"></div>
  </div>

  <!-- Edit Room Description Modal (Admin only) -->
  <div id="editDescriptionModal" class="modal" style="display:none;min-width:400px;max-width:500px">
    <h3>Edit Room Description</h3>
    <textarea id="roomDescriptionInput" placeholder="Enter room description..." style="min-height:100px;margin-bottom:15px"></textarea>
    <div class="modal-btns">
      <button id="cancelEditDescription" class="modal-btn modal-btn-cancel">Cancel</button>
      <button id="confirmEditDescription" class="modal-btn modal-btn-confirm">Save</button>
    </div>
    <div id="editDescriptionMsg" class="modal-msg"></div>
  </div>

  <!-- Profile Modal -->
  <div id="profileModal" class="modal" style="display:none;min-width:400px;max-width:450px">
    <h3>Your Profile</h3>
    <div style="display:flex;align-items:center;gap:12px;margin-bottom:15px">
      <div id="profileModalAvatar" style="width:56px;height:56px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;color:#000;font-size:20px;background:var(--guest-gray)"></div>
      <div>
        <div id="profileModalName" style="font-weight:700;font-size:18px"></div>
        <div id="profileModalRole" style="font-size:13px;color:var(--muted)"></div>
      </div>
    </div>
    <label style="display:block;margin-bottom:6px;font-size:14px;color:var(--muted)">Profile Description</label>
    <textarea id="profileDescriptionInput" placeholder="Tell others about yourself..." style="min-height:100px;margin-bottom:15px"></textarea>
    <div class="modal-btns">
      <button id="cancelProfile" class="modal-btn modal-btn-cancel">Cancel</button>
      <button id="saveProfile" class="modal-btn modal-btn-confirm">Save</button>
    </div>
    <div id="profileMsg" class="modal-msg"></div>
  </div>

  <!-- Room Description Tooltip -->
  <div id="roomDescriptionTooltip" class="room-tooltip tooltip" style="display:none;max-width:300px;font-size:13px">
    <div id="roomDescriptionText" style="color:var(--muted)"></div>
  </div>

  <!-- Create Room Modal -->
  <div id="createRoomModal" class="modal" style="display:none;min-width:350px;max-width:450px">
    <h3>Create Room</h3>
    <input id="newRoomName" placeholder="Room name">
    <input id="newRoomPassword" type="password" placeholder="Password (optional)">
    <textarea id="newRoomDescription" placeholder="Description (optional)" style="min-height:80px;margin-bottom:15px"></textarea>
    <div class="modal-btns">
      <button id="cancelCreateRoom" class="modal-btn modal-btn-cancel">Cancel</button>
      <button id="confirmCreateRoom" class="modal-btn modal-btn-confirm">Create</button>
    </div>
    <div id="createRoomMsg" class="modal-msg"></div>
  </div>

  <!-- Custom Alert Modal (replaces native alert) -->
  <div id="customAlertModal" class="modal" style="display:none;min-width:320px;max-width:400px">
    <div id="customAlertIcon" style="font-size:32px;margin-bottom:12px;text-align:center">â„¹ï¸</div>
    <div id="customAlertMessage" style="font-size:14px;text-align:center;margin-bottom:20px;line-height:1.5"></div>
    <div style="display:flex;justify-content:center">
      <button id="customAlertOk" class="modal-btn modal-btn-confirm" style="padding:10px 32px">OK</button>
    </div>
  </div>

  <!-- Custom Confirm Modal (replaces native confirm) -->
  <div id="customConfirmModal" class="modal" style="display:none;min-width:320px;max-width:400px;z-index:250">
    <div id="customConfirmIcon" style="font-size:32px;margin-bottom:12px;text-align:center">â“</div>
    <div id="customConfirmMessage" style="font-size:14px;text-align:center;margin-bottom:20px;line-height:1.5"></div>
    <div class="modal-btns" style="justify-content:center">
      <button id="customConfirmCancel" class="modal-btn modal-btn-cancel">Cancel</button>
      <button id="customConfirmOk" class="modal-btn modal-btn-confirm">Confirm</button>
    </div>
  </div>

  <!-- Custom Prompt Modal (replaces native prompt) -->
  <div id="customPromptModal" class="modal" style="display:none;min-width:320px;max-width:400px">
    <div id="customPromptIcon" style="font-size:32px;margin-bottom:12px;text-align:center">ğŸ’¬</div>
    <div id="customPromptMessage" style="font-size:14px;text-align:center;margin-bottom:15px;line-height:1.5"></div>
    <input id="customPromptInput" type="text" style="padding:12px;font-size:14px;margin-bottom:15px">
    <div class="modal-btns" style="justify-content:center">
      <button id="customPromptCancel" class="modal-btn modal-btn-cancel">Cancel</button>
      <button id="customPromptOk" class="modal-btn modal-btn-confirm">OK</button>
    </div>
  </div>

  <!-- Nick Color Picker Modal -->
  <div id="nickColorModal" class="modal" style="display:none;min-width:280px;max-width:350px">
    <h3>ğŸ¨ Choose Your Color</h3>
    <div id="colorGrid" class="color-grid">
      <div class="color-option" data-color="#58a6ff" style="background:#58a6ff"></div>
      <div class="color-option" data-color="#ff6b6b" style="background:#ff6b6b"></div>
      <div class="color-option" data-color="#51cf66" style="background:#51cf66"></div>
      <div class="color-option" data-color="#ffd43b" style="background:#ffd43b"></div>
      <div class="color-option" data-color="#cc5de8" style="background:#cc5de8"></div>
      <div class="color-option" data-color="#ff922b" style="background:#ff922b"></div>
      <div class="color-option" data-color="#20c997" style="background:#20c997"></div>
      <div class="color-option" data-color="#ff8787" style="background:#ff8787"></div>
      <div class="color-option" data-color="#74c0fc" style="background:#74c0fc"></div>
      <div class="color-option" data-color="#845ef7" style="background:#845ef7"></div>
    </div>
    <div class="modal-btns">
      <button id="cancelNickColor" class="modal-btn modal-btn-cancel">Cancel</button>
    </div>
  </div>

  <!-- Super Admin Modal -->
  <div id="superAdminModal" class="modal" style="display:none;min-width:500px;max-width:600px;width:550px;height:550px;z-index:200">
    <h3 style="display:flex;align-items:center;gap:10px">
      <span style="font-size:20px">âš ï¸</span> Super Admin
      <span id="superAdminBadge" style="font-size:11px;background:#ff6b6b;color:#000;padding:2px 8px;border-radius:4px;font-weight:700">ADMIN</span>
    </h3>
    <div id="superAdminAuth" style="display:flex;flex-direction:column;gap:10px">
      <p style="font-size:13px;color:var(--muted);margin-bottom:5px">Enter your Super Admin password to access admin controls.</p>
      <input id="superAdminPassword" type="password" placeholder="Super Admin Password" style="padding:12px;font-size:14px">
      <div class="modal-btns">
        <button id="cancelSuperAdmin" class="modal-btn modal-btn-cancel">Cancel</button>
        <button id="authSuperAdmin" class="modal-btn modal-btn-confirm">Authenticate</button>
      </div>
      <div id="superAdminMsg" class="modal-msg"></div>
    </div>
    <div id="superAdminPanel" style="display:none;flex-direction:column;flex:1;min-height:0">
      <!-- Stats Bar -->
      <div id="superAdminStats" style="display:flex;gap:15px;margin-bottom:15px;padding:12px;background:var(--card);border-radius:8px">
        <div style="flex:1;text-align:center">
          <div id="statRooms" style="font-size:22px;font-weight:700;color:var(--accent)">-</div>
          <div style="font-size:11px;color:var(--muted)">Rooms</div>
        </div>
        <div style="flex:1;text-align:center">
          <div id="statUsers" style="font-size:22px;font-weight:700;color:#51cf66">-</div>
          <div style="font-size:11px;color:var(--muted)">Users</div>
        </div>
        <div style="flex:1;text-align:center">
          <div id="statOnline" style="font-size:22px;font-weight:700;color:#ffd43b">-</div>
          <div style="font-size:11px;color:var(--muted)">Online</div>
        </div>
      </div>
      <!-- Search -->
      <input id="superAdminSearch" type="text" placeholder="Search rooms or users..." style="width:100%;padding:10px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.1);background:var(--card);color:var(--text);margin-bottom:12px;box-sizing:border-box">
      <!-- Tabs -->
      <div style="display:flex;gap:8px;margin-bottom:15px">
        <button id="superAdminRoomsTab" class="modal-btn" style="flex:1;padding:10px;border-radius:8px;border:0;background:var(--card);color:var(--text);font-weight:600;cursor:pointer">ğŸ  Rooms</button>
        <button id="superAdminUsersTab" class="modal-btn" style="flex:1;padding:10px;border-radius:8px;border:0;background:transparent;color:var(--text);font-weight:600;cursor:pointer">ğŸ‘¥ Users</button>
      </div>
      <!-- Lists -->
      <div id="superAdminRoomsList" style="flex:1;overflow-y:auto;min-height:0"></div>
      <div id="superAdminUsersList" style="display:none;flex:1;overflow-y:auto;min-height:0"></div>
      <!-- Actions -->
      <div style="display:flex;gap:10px;margin-top:15px;padding-top:15px;border-top:1px solid rgba(255,255,255,0.1)">
        <button id="superAdminDeleteAllRooms" style="flex:1;padding:10px;border-radius:8px;border:0;background:rgba(255,107,107,0.2);color:#ff6b6b;font-weight:600;cursor:pointer;font-size:13px">ğŸ’¥ Delete All Rooms</button>
        <button id="closeSuperAdmin" class="modal-btn modal-btn-cancel" style="padding:10px 20px">Close</button>
      </div>
    </div>
  </div>

  <!-- Set Super Admin Password Modal -->
  <div id="setSuperAdminModal" class="modal" style="display:none;min-width:400px;z-index:200">
    <h3 style="display:flex;align-items:center;gap:10px">
      <span style="font-size:20px">ğŸ”</span> Set Super Admin Password
    </h3>
    <p style="font-size:13px;color:var(--muted);margin-bottom:15px;line-height:1.5">Create a password to access Super Admin features. This gives you full control to delete any room or user.<br><br><strong style="color:#ffd43b">âš ï¸ Save this password somewhere safe - there is no recovery!</strong></p>
    <input id="newSuperAdminPassword" type="password" placeholder="New Super Admin Password" style="padding:12px;font-size:14px;margin-bottom:10px">
    <input id="confirmSuperAdminPassword" type="password" placeholder="Confirm Password" style="padding:12px;font-size:14px;margin-bottom:15px">
    <div class="modal-btns">
      <button id="cancelSetSuperAdmin" class="modal-btn modal-btn-cancel" style="padding:10px 20px">Skip</button>
      <button id="confirmSetSuperAdmin" class="modal-btn modal-btn-confirm" style="padding:10px 24px">Set Password</button>
    </div>
    <div id="setSuperAdminMsg" class="modal-msg"></div>
  </div>

  <!-- Roles Modal -->
  <div id="rolesModal" class="modal" style="display:none;min-width:300px;max-width:400px;max-height:80vh;overflow-y:auto">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px">
      <h3 style="margin:0">ğŸ­ Choose Your Role</h3>
      <button id="closeRoles" class="iconbtn" style="font-size:20px;background:transparent;border:none;color:var(--text);cursor:pointer">âœ•</button>
    </div>
    <div id="rolesList"></div>
    <div style="margin-top:15px;padding-top:15px;border-top:1px solid #0d1117">
      <button id="viewAllRoles" style="width:100%;padding:10px;border-radius:8px;border:1px solid var(--accent);background:transparent;color:var(--accent);cursor:pointer;font-weight:600">View All Roles</button>
    </div>
  </div>

  <!-- HOW TO PANEL (text moved to how.html; kept small link here so DOM & ids remain) -->
  <div id="howMenu" class="how-menu" aria-hidden="true">
    <h3>How to use â€” Features &amp; Tips</h3>
    <div class="section">Full "How To" text has been moved to <a href="how.html" target="_blank" rel="noopener">how.html</a>. Click the button or press '?' to open it in a new tab.</div>
    <button id="closeHow" class="close-how">Close</button>
  </div>

  <!-- PROFILE CARD (also used when hovering/clicking a user) -->
  <div id="profileCard" class="profile-card" aria-hidden="true">
    <div style="display:flex;align-items:center;gap:10px;margin-bottom:8px">
      <div id="profileAvatar" style="width:48px;height:48px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;color:#000;background:var(--guest-gray)"></div>
      <div>
        <div id="profileName" style="font-weight:700"></div>
        <div id="profileJoined" style="font-size:13px;color:var(--muted)"></div>
      </div>
    </div>
    <div class="profile-row"><div>Color</div><div id="profileColor"></div></div>
    <div id="profileCardDescription" style="display:none;margin-top:10px;font-size:13px;color:var(--muted);border-top:1px solid rgba(255,255,255,0.06);padding-top:8px;white-space:pre-wrap;word-break:break-word"></div>
  </div>

  <!-- LOGIN -->
  <div id="login" aria-hidden="false">
    <div class="auth-tabs">
      <button id="loginTab" class="auth-tab active">Sign In</button>
      <button id="registerTab" class="auth-tab">Create Account</button>
    </div>

    <!-- Login Panel -->
    <div id="loginPanel" class="auth-panel active">
      <input id="loginUser" placeholder="Username" autocomplete="username">
      <input id="loginPass" type="password" placeholder="Password" autocomplete="current-password">
      <button id="loginBtn">Sign In</button>
    </div>

    <!-- Register Panel -->
    <div id="registerPanel" class="auth-panel">
      <input id="regUser" placeholder="Username" autocomplete="username">
      <input id="regPass" type="password" placeholder="Password" autocomplete="new-password">
      <input id="regPassConfirm" type="password" placeholder="Confirm Password" autocomplete="new-password">
      <button id="registerBtn">Create Account</button>
    </div>

    <button id="demoBtn" class="small">Continue as Guest</button>
    <div id="loginMsg"></div>
  </div>

  <!-- HOME -->
  <div id="home">
    <!-- Desktop lobby (keeps desktop visible) -->
    <aside id="homeLeft" aria-label="Lobby">
      <div id="lobbyHeader">
        <div id="lobbyTitle">Rooms</div>
        <div id="lobbyControls">
          <button id="lobbyToggle" class="iconbtn" title="Collapse/Expand lobby">â—€</button>
          <button id="lobbySizeBtn" class="iconbtn" title="Change lobby size">A</button>
        </div>
      </div>
      <div id="roomList"></div>
    </aside>

    <!-- Center -->
    <main id="homeCenter">
      <div id="clockWidget">00:00</div>
      <img id="homeLogo" src="images/echo_space.png" alt="">

      <button id="createRoom" class="createRoom">Create / Join Room</button>
      <button id="nickColorBtn" class="nickColorBtn" title="Change Name Color">ğŸ¨ Color</button>
      <button id="startDmBtn" class="nickColorBtn" title="Start Direct Message" style="border-color:#845ef7;display:none">ğŸ’¬ New DM</button>
    </main>

  </div>

  <!-- MAIN CHAT -->
  <div id="main" aria-hidden="true">
    <div id="header">
      <div class="left">
        <button id="back" class="iconbtn" title="Back">â†</button>
        <div id="roomName">#room</div>
        <button id="editDescriptionBtn" class="iconbtn" title="Edit Description" style="display:none;font-size:12px;margin-left:8px">âœ</button>
      </div>
      <div style="flex:1"></div>
    </div>

    <div id="chatWrapper">
      <aside id="chatSidebar" aria-label="Chat sidebar">
        <div class="sidebar-header">
          <div>Rooms</div>
          <button id="sidebarToggle" class="iconbtn" title="Collapse">â—€</button>
        </div>
        <div id="roomListSidebar"></div>
      </aside>

      <div id="chatWrapperMain">
        <div id="chat"></div>

        <!-- TYPING INDICATOR: appears between chat and input -->
        <div id="typingIndicator" aria-live="polite"></div>

        <div id="replyBox"></div>
        <div id="inputBar">
          <button id="emojiBtn" aria-label="Emoji picker"><span class="emoji-icon" aria-hidden="true">ğŸ˜Š</span></button>
          <button id="gifBtn" aria-label="GIF picker">GIF</button>
          <input id="msg" placeholder="Message... (â†‘ for last message, /clear /delete)" autocomplete="off">
          <div id="emojiPicker"></div>
          <div id="gifPicker">
            <input type="text" id="gifSearch" placeholder="Search GIFs..." autocomplete="off">
            <div id="gifResults"></div>
          </div>
        </div>
      </div>
    </div>

  </div>
  
   <!-- Online Users Floating Button (next to drawer header) -->
   <button id="toggleOnlineUsers" class="iconbtn" title="Online Users" style="display:none;position:fixed;right:12px;top:66px;font-size:16px;padding:8px 10px;background:var(--panel);border:1px solid #30363d;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.3);z-index:96">
     <span id="onlineUsersBtnIcon">ğŸ‘¥</span>
     <span id="onlineUsersBadge" style="display:none;position:absolute;top:-5px;right:-5px;background:#ff6b6b;color:#000;font-size:10px;padding:2px 5px;border-radius:10px;font-weight:700"></span>
   </button>

   <!-- Online Users Drawer (positioned relative to viewport) -->
   <aside id="onlineUsersDrawer" style="position:fixed;right:0;top:56px;height:calc(100% - 56px);width:240px;background:var(--panel);border-left:1px solid #0d1117;padding:12px;transform:translateX(100%);transition:transform 300ms ease;z-index:95;overflow-y:auto;box-shadow:-4px 0 20px rgba(0,0,0,.4);pointer-events:auto">
     <div class="online-users-header">
       <div>Online Users</div>
       <button id="closeOnlineUsers" class="iconbtn" style="font-size:18px">âœ•</button>
     </div>
     <div id="onlineUsersList"></div>
   </aside>

   <!-- DM Panel -->
   <aside id="dmPanel" style="position:fixed;left:0;top:0;height:100%;width:360px;background:var(--panel);border-right:1px solid #0d1117;transform:translateX(-100%);transition:transform 300ms ease;z-index:100;display:flex;flex-direction:column">
     <div style="padding:16px;border-bottom:1px solid #0d1117;display:flex;align-items:center;justify-content:space-between">
       <div style="font-weight:600;font-size:15px">ğŸ’¬ Direct Messages</div>
       <button id="closeDmPanel" class="iconbtn" style="font-size:18px">âœ•</button>
     </div>
     
     <!-- Tabs -->
     <div style="display:flex;border-bottom:1px solid #0d1117">
       <button id="dmConversationsTab" class="dm-tab active" style="flex:1;padding:12px;border:0;background:transparent;color:var(--text);font-weight:600;cursor:pointer;font-size:13px">Recent</button>
        <button id="dmAllUsersTab" class="dm-tab" style="flex:1;padding:12px;border:0;background:transparent;color:var(--text);font-weight:600;cursor:pointer;font-size:13px">All Users</button>
     </div>
     
     <div id="dmConversations" style="flex:1;overflow-y:auto;padding:8px"></div>
     <div id="dmAllUsers" style="flex:1;overflow-y:auto;padding:8px;display:none"></div>
     
     <div id="dmEmptyState" style="padding:12px;border-top:1px solid #0d1117;text-align:center;color:var(--muted);font-size:13px;padding:20px">No conversations yet.<br>Click on a user to start a DM.</div>
   </aside>

   <!-- DM Chat View (Full Screen Mode) -->
   <aside id="dmChatPanel" style="display:none;position:fixed;inset:0;background:var(--bg);z-index:110;flex-direction:column">
     <div style="height:56px;background:var(--panel);display:flex;align-items:center;padding:8px 12px;border-bottom:1px solid #0d1117">
       <button id="backFromDm" class="iconbtn" style="font-size:18px;margin-right:8px" title="Back">â†</button>
       <div id="dmChatHeader" style="flex:1">
         <div id="dmChatUsername" style="font-weight:700;font-size:16px"></div>
         <div id="dmChatStatus" style="font-size:12px;color:var(--muted)"></div>
       </div>
     </div>
     <div id="dmMessages" style="flex:1;overflow-y:auto;padding:16px;display:flex;flex-direction:column;gap:10px;background:linear-gradient(180deg,transparent,rgba(255,255,255,.01))"></div>
     <div id="dmInputArea" style="padding:12px;background:var(--panel);border-top:1px solid #0d1117;display:flex;gap:8px;align-items:center">
        <input id="dmInput" placeholder="Type a message... (â†‘ for last message, /clear to delete all)" style="flex:1;padding:12px;border-radius:10px;border:0;background:var(--card);color:var(--text);font-size:14px;outline:none">
       <button id="dmSendBtn" style="padding:12px 20px;border-radius:10px;border:0;background:var(--accent);color:#000;font-weight:700;cursor:pointer;font-size:14px">Send</button>
     </div>
   </aside>

   <!-- Mobile overlay and drawer (kept in DOM but mobile logic removed) -->
  <div id="mobileOverlay" class="mobile-overlay" aria-hidden="true"></div>
  <div id="mobileDrawer" class="mobile-lobby-drawer" aria-hidden="true">
    <div class="drawer-header">
      <div>Rooms</div>
      <button id="closeDrawer" class="iconbtn">âœ•</button>
    </div>
    <div id="roomListMobile"></div>
  </div>

  <!-- Blue three-line button (mobile) -->
  <button id="openLobbyBtn" title="Open lobby">â˜°</button>

  <!-- Floating scroll to bottom button (now centered) -->
  <button id="scrollBottomBtn" title="Scroll to bottom">â†“</button>

  <!-- tooltip element -->
  <div id="tooltip" class="tooltip" aria-hidden="true"></div>

  <!-- context menu element (right-click / three-dots / long-press) -->
  <div id="contextMenu" class="context-menu" aria-hidden="true"></div>

  <!-- Enhanced reaction picker popup -->
  <div id="reactionPicker" class="reaction-picker" aria-hidden="true">
    <div class="reaction-picker-header">
      <span>Quick Reactions</span>
    </div>
    <div class="reaction-picker-grid">
      <span class="emoji-option" data-emoji="ğŸ‘">ğŸ‘</span>
      <span class="emoji-option" data-emoji="â¤ï¸">â¤ï¸</span>
      <span class="emoji-option" data-emoji="ğŸ˜‚">ğŸ˜‚</span>
      <span class="emoji-option" data-emoji="ğŸ˜®">ğŸ˜®</span>
      <span class="emoji-option" data-emoji="ğŸ˜¢">ğŸ˜¢</span>
      <span class="emoji-option" data-emoji="ğŸ”¥">ğŸ”¥</span>
      <span class="emoji-option" data-emoji="ğŸ‰">ğŸ‰</span>
      <span class="emoji-option" data-emoji="ğŸ¤”">ğŸ¤”</span>
      <span class="emoji-option" data-emoji="ğŸ‘">ğŸ‘</span>
      <span class="emoji-option" data-emoji="ğŸ˜">ğŸ˜</span>
      <span class="emoji-option" data-emoji="ğŸ¤¯">ğŸ¤¯</span>
      <span class="emoji-option" data-emoji="ğŸ¥³">ğŸ¥³</span>
      <span class="emoji-option" data-emoji="ğŸ˜­">ğŸ˜­</span>
      <span class="emoji-option" data-emoji="ğŸ˜¡">ğŸ˜¡</span>
      <span class="emoji-option" data-emoji="ğŸ¤©">ğŸ¤©</span>
      <span class="emoji-option" data-emoji="ğŸ™Œ">ğŸ™Œ</span>
      <span class="emoji-option" data-emoji="ğŸ‘">ğŸ‘</span>
      <span class="emoji-option" data-emoji="ğŸ¤£">ğŸ¤£</span>
      <span class="emoji-option" data-emoji="ğŸ˜´">ğŸ˜´</span>
      <span class="emoji-option" data-emoji="ğŸ¤¢">ğŸ¤¢</span>
    </div>
  </div>

</div>

<script type="module">
/* ===================
   Tehty: poistettu kÃ¤yttÃ¤mÃ¤ttÃ¶miÃ¤ mobiilikoodin osia, mutta
   kaikki funktiot ja ID:t sÃ¤ilytetty nimillÃ¤Ã¤n (ei refaktorointia).
   - isMobile/isTouch sÃ¤ilytetty false (mobiilituki pois pÃ¤Ã¤ltÃ¤)
   - Edge-swipe ja monimutkainen drawer-drag-logiikka poistettu
   - attachMobileInteractions supistettu turvalliseksi no-opiksi
   =================== */

import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, collection,
  addDoc, getDocs, query, orderBy, where, limit,
  onSnapshot, serverTimestamp, deleteDoc, updateDoc, writeBatch
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

/* Firebase init - replace config if needed */
const firebaseConfig = {
  apiKey:"AIzaSyBQp4PDYkut30VTVN0qD2871CdhJZqXqRc",
  projectId:"chat-fc8ef"
};
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

// Super Admin functions
async function checkSuperAdminSetup() {
  try {
    const docRef = doc(db, 'superadmin', 'config');
    const docSnap = await getDoc(docRef);
    return docSnap.exists();
  } catch(e) {
    return false;
  }
}

async function verifySuperAdminPassword(password) {
  try {
    const docRef = doc(db, 'superadmin', 'config');
    const docSnap = await getDoc(docRef);
    if(!docSnap.exists()) return false;
    return docSnap.data().password === password;
  } catch(e) {
    return false;
  }
}

/* DOM refs */
const howBtn = document.getElementById('howBtn');
const howMenu = document.getElementById('howMenu');
const fullBtn = document.getElementById('fullBtn');

const login = document.getElementById('login');
const home = document.getElementById('home');
const main = document.getElementById('main');
const loginBtn = document.getElementById('loginBtn');
const demoBtn = document.getElementById('demoBtn');
const loginUser = document.getElementById('loginUser');
const loginPass = document.getElementById('loginPass');
const loginMsg = document.getElementById('loginMsg');

const roomList = document.getElementById('roomList');
const roomListSidebar = document.getElementById('roomListSidebar');
const roomListMobile = document.getElementById('roomListMobile');

const createRoomBtn = document.getElementById('createRoom');
const editDescriptionBtn = document.getElementById('editDescriptionBtn');
const editDescriptionModal = document.getElementById('editDescriptionModal');
const roomDescriptionInput = document.getElementById('roomDescriptionInput');
const cancelEditDescription = document.getElementById('cancelEditDescription');
const confirmEditDescription = document.getElementById('confirmEditDescription');
const editDescriptionMsg = document.getElementById('editDescriptionMsg');
const roomDescriptionTooltip = document.getElementById('roomDescriptionTooltip');
const roomDescriptionText = document.getElementById('roomDescriptionText');

const toggleOnlineUsers = document.getElementById('toggleOnlineUsers');
const onlineUsersDrawer = document.getElementById('onlineUsersDrawer');
const closeOnlineUsers = document.getElementById('closeOnlineUsers');
const onlineUsersList = document.getElementById('onlineUsersList');

const createRoomModal = document.getElementById('createRoomModal');
const newRoomName = document.getElementById('newRoomName');
const newRoomPassword = document.getElementById('newRoomPassword');
const newRoomDescription = document.getElementById('newRoomDescription');
const cancelCreateRoom = document.getElementById('cancelCreateRoom');
const confirmCreateRoom = document.getElementById('confirmCreateRoom');
const createRoomMsg = document.getElementById('createRoomMsg');

// Roles modal DOM references
const rolesModal = document.getElementById('rolesModal');
const rolesList = document.getElementById('rolesList');
const closeRoles = document.getElementById('closeRoles');
const viewAllRoles = document.getElementById('viewAllRoles');

// Nick color picker DOM references
const nickColorModal = document.getElementById('nickColorModal');
const nickColorBtn = document.getElementById('nickColorBtn');
const colorGrid = document.getElementById('colorGrid');

const clockWidget = document.getElementById('clockWidget');
const cancelNickColor = document.getElementById('cancelNickColor');

const lobby = document.getElementById('homeLeft');
const lobbyToggle = document.getElementById('lobbyToggle');
const lobbySizeBtn = document.getElementById('lobbySizeBtn');

const chatSidebar = document.getElementById('chatSidebar');
const sidebarToggle = document.getElementById('sidebarToggle');

const openLobbyBtn = document.getElementById('openLobbyBtn');
const mobileOverlay = document.getElementById('mobileOverlay');
const mobileDrawer = document.getElementById('mobileDrawer');
const closeDrawer = document.getElementById('closeDrawer');

const chat = document.getElementById('chat');
const chatWrapperMain = document.getElementById('chatWrapperMain');
const msg = document.getElementById('msg');
const replyBox = document.getElementById('replyBox');
const roomName = document.getElementById('roomName');
const emojiPicker = document.getElementById('emojiPicker');
const emojiBtn = document.getElementById('emojiBtn');
const gifPicker = document.getElementById('gifPicker');
const gifBtn = document.getElementById('gifBtn');
const gifSearch = document.getElementById('gifSearch');
const gifResults = document.getElementById('gifResults');
const typingIndicator = document.getElementById('typingIndicator');

// Typing

typingIndicator.innerHTML = `
  <div class="typing-avatars"></div>
  <div class="typing-text">
    <div class="typing-label"></div>
    <div class="typing-dots">
      <span></span><span></span><span></span>
    </div>
  </div>
`;


const back = document.getElementById('back');

const settingsBtn = document.getElementById('settingsBtn');
const settingsMenu = document.getElementById('settingsMenu');
const settingsLogout = document.getElementById('settingsLogout');
const settingsDelete = document.getElementById('settingsDelete');

const notificationsToggle = document.getElementById('notificationsToggle');

// Load notification preference
if(notificationsToggle) {
  notificationsToggle.checked = localStorage.getItem('notificationsEnabled') === 'true';
  notificationsToggle.addEventListener('change', () => {
    localStorage.setItem('notificationsEnabled', notificationsToggle.checked ? 'true' : 'false');
    if(notificationsToggle.checked && 'Notification' in window && Notification.permission !== 'granted') {
      Notification.requestPermission();
    }
  });
}

const profileCard = document.getElementById('profileCard');
const profileAvatar = document.getElementById('profileAvatar');
const profileName = document.getElementById('profileName');
const profileJoined = document.getElementById('profileJoined');
const profileColor = document.getElementById('profileColor');

// Profile modal DOM references
const profileBtn = document.getElementById('profileBtn');
const profileModal = document.getElementById('profileModal');
const profileModalAvatar = document.getElementById('profileModalAvatar');
const profileModalName = document.getElementById('profileModalName');
const profileModalRole = document.getElementById('profileModalRole');
const profileDescriptionInput = document.getElementById('profileDescriptionInput');
const cancelProfile = document.getElementById('cancelProfile');
const saveProfile = document.getElementById('saveProfile');
const profileMsg = document.getElementById('profileMsg');

const scrollBottomBtn = document.getElementById('scrollBottomBtn');
const tooltip = document.getElementById('tooltip');
const contextMenu = document.getElementById('contextMenu');
const reactionPicker = document.getElementById('reactionPicker');

let users = JSON.parse(localStorage.getItem('users')||'{}');
let nick = '';
let nickColor = localStorage.getItem('nickColor')||'#58a6ff';
let room = '';
let replyTo = null;
let lastMessageTime = 0;
let lastOwnMessage = '';
let typingTimeout = null;
let messagesUnsub = null;
let typingUnsub = null;
let roomsUnsub = null; // <--- listener for rooms collection

/* Track if current user is admin of current room and who the admins are */
let isAdmin = false;
let roomAdmins = [];

/* cache for user docs to avoid repeated reads */
const userCache = new Map();

/* Device detection - mobile support disabled per request */
const isTouch = false; // mobile support disabled
const isMobile = false; // mobile support disabled

/* UI init */

/* Ensure desktop lobby visible and cannot be collapsed */
function enforceDesktopLobby(){
  if(!isMobile){
    lobby.style.display = 'block';
    chatSidebar.style.display = 'block';
    if(lobbyToggle) lobbyToggle.style.display = 'none';
    if(sidebarToggle) sidebarToggle.style.display = 'none';
  } else {
    lobby.style.display = 'none';
    chatSidebar.style.display = 'none';
  }
}
enforceDesktopLobby();

/* Clock Widget */
function updateClock(){
   const now = new Date();
   const hours = String(now.getHours()).padStart(2, '0');
   const minutes = String(now.getMinutes()).padStart(2, '0');
   const seconds = String(now.getSeconds()).padStart(2, '0');
   clockWidget.textContent = `${hours}:${minutes}:${seconds}`;
  }
setInterval(updateClock, 1000);
updateClock();

/* NOTE:
   Edge-swipe touch handlers and complex drawer drag logic removed because isMobile is false.
   Keeping DOM elements and function names to avoid breaking existing references.
*/

/* Session helpers */
function showHome(){
  login.style.display = 'none';
  home.style.display = 'flex';
  main.style.display = 'none';
  // Update nickColor from localStorage on home load
  nickColor = localStorage.getItem('nickColor') || '#58a6ff';
  // show top-right controls on home
  if(howBtn) howBtn.style.display = '';
  if(fullBtn) fullBtn.style.display = '';
  if(settingsBtn) settingsBtn.style.display = '';
  if(profileBtn) profileBtn.style.display = '';
  if(document.getElementById('openDMPanel')) document.getElementById('openDMPanel').style.display = '';
  if(document.getElementById('startDmBtn')) {
    const session = localStorage.getItem('session');
    document.getElementById('startDmBtn').style.display = session && !session.startsWith('Guest') ? '' : 'none';
  }
  // hide online users button and close drawer
  if(toggleOnlineUsers) toggleOnlineUsers.style.display = 'none';
  if(onlineUsersDrawer) {
    onlineUsersDrawer.classList.remove('show');
    onlineUsersDrawer.setAttribute('aria-hidden', 'true');
  }
  updateOpenLobbyBtnVisibility();
  // Request notification permission once in lobby (if not already decided)
  if('Notification' in window && Notification.permission === 'default' && !localStorage.getItem('notificationsAsked')) {
    localStorage.setItem('notificationsAsked', 'true');
    Notification.requestPermission().then(permission => {
      if(permission === 'granted') {
        localStorage.setItem('notificationsEnabled', 'true');
      }
    });
  }
}
function showLogin(){
  login.style.display = 'flex';
  home.style.display = 'none';
  main.style.display = 'none';
  main.setAttribute('aria-hidden', 'true');
  localStorage.removeItem('session');
  // hide top-right controls on login screen
  if(howBtn) howBtn.style.display = 'none';
  if(fullBtn) fullBtn.style.display = 'none';
  if(settingsBtn) settingsBtn.style.display = 'none';
  if(profileBtn) profileBtn.style.display = 'none';
  if(document.getElementById('openDMPanel')) document.getElementById('openDMPanel').style.display = 'none';
  if(document.getElementById('startDmBtn')) document.getElementById('startDmBtn').style.display = 'none';
  // hide online users button and close drawer
  if(toggleOnlineUsers) toggleOnlineUsers.style.display = 'none';
  if(onlineUsersDrawer) {
    onlineUsersDrawer.classList.remove('show');
    onlineUsersDrawer.setAttribute('aria-hidden', 'true');
  }
  updateOpenLobbyBtnVisibility();
}
function showMain(){
  login.style.display = 'none';
  home.style.display = 'none';
  main.style.display = 'flex';
  main.setAttribute('aria-hidden', 'false');
  // show top-right controls on main
  if(howBtn) howBtn.style.display = '';
  if(fullBtn) fullBtn.style.display = '';
  if(settingsBtn) settingsBtn.style.display = '';
  if(profileBtn) profileBtn.style.display = '';
  if(document.getElementById('openDMPanel')) document.getElementById('openDMPanel').style.display = '';
  if(document.getElementById('startDmBtn')) document.getElementById('startDmBtn').style.display = 'none';
  // show online users button in chat
  if(toggleOnlineUsers) toggleOnlineUsers.style.display = 'block';
  updateOpenLobbyBtnVisibility();
}

/* restore session */
if(localStorage.getItem('session')) showHome();
else showLogin();

/* HOW TO click changed to open how.html in a new tab */
howBtn.addEventListener('click', (e) => { e.stopPropagation(); window.open('how.html','_blank'); });
document.getElementById('closeHow').addEventListener('click', (e) => {
  e.stopPropagation();
  howMenu.classList.remove('show');
  howMenu.setAttribute('aria-hidden','true');
});

/* Fullscreen toggle */
async function toggleFullScreen(){
  try{
    if(!document.fullscreenElement){
      await document.documentElement.requestFullscreen();
      fullBtn.title = "Exit fullscreen";
    } else {
      await document.exitFullscreen();
      fullBtn.title = "Enter fullscreen";
    }
  }catch(e){}
}
fullBtn.addEventListener('click', (e)=>{ e.stopPropagation(); toggleFullScreen(); });

/* Profile button - open profile modal */
profileBtn.addEventListener('click', async (e) => {
  e.stopPropagation();
  profileMsg.textContent = '';
  profileDescriptionInput.value = localStorage.getItem('profileDescription') || '';
  profileModalAvatar.textContent = nick.charAt(0).toUpperCase();
  profileModalAvatar.style.background = nickColor;
  profileModalName.textContent = nick;
  const userRole = localStorage.getItem('userRole') || '';
  profileModalRole.textContent = userRole ? `Role: ${userRole}` : 'No role selected';
  profileModal.style.display = 'block';
});

/* Profile modal handlers */
cancelProfile.addEventListener('click', () => {
  profileModal.style.display = 'none';
});

saveProfile.addEventListener('click', async () => {
  const description = profileDescriptionInput.value.trim();
  localStorage.setItem('profileDescription', description);
  localStorage.setItem(`profileDesc_${nick}`, description);

  // Save to Firestore for registered users (not guests)
  const currentUid = localStorage.getItem('session') || '';
  if (currentUid && !currentUid.startsWith('Guest')) {
    try {
      const userRef = doc(db, 'users', currentUid);
      await updateDoc(userRef, { description: description });
    } catch (e) {
      console.error('Failed to save profile description to Firestore:', e);
    }
  }

  profileMsg.textContent = 'Profile saved!';
  profileMsg.style.color = '#3fb950';
  setTimeout(() => {
    profileModal.style.display = 'none';
    profileMsg.textContent = '';
  }, 800);
});

/* Close profile modal on outside click */
profileModal.addEventListener('click', (e) => {
  if (e.target === profileModal) {
    profileModal.style.display = 'none';
  }
});

// Keep profile card visible when hovering over it
profileCard.addEventListener('mouseenter', () => {
  profileCard.classList.add('show');
  profileCard.setAttribute('aria-hidden', 'false');
});
profileCard.addEventListener('mouseleave', () => {
  profileCard.classList.remove('show');
  profileCard.setAttribute('aria-hidden', 'true');
});

/* ====== Custom Modal System (replaces native alert/confirm/prompt) ====== */
const customAlertModal = document.getElementById('customAlertModal');
const customConfirmModal = document.getElementById('customConfirmModal');
const customPromptModal = document.getElementById('customPromptModal');

function showCustomAlert(message, icon = 'â„¹ï¸') {
  return new Promise((resolve) => {
    document.getElementById('customAlertMessage').textContent = message;
    document.getElementById('customAlertIcon').textContent = icon;
    customAlertModal.style.display = 'block';
    document.getElementById('customAlertOk').onclick = () => {
      customAlertModal.style.display = 'none';
      resolve();
    };
  });
}

function showCustomConfirm(message, icon = 'â“') {
  return new Promise((resolve) => {
    document.getElementById('customConfirmMessage').textContent = message;
    document.getElementById('customConfirmIcon').textContent = icon;
    customConfirmModal.style.display = 'block';
    const okBtn = document.getElementById('customConfirmOk');
    const cancelBtn = document.getElementById('customConfirmCancel');
    const handler = (result) => {
      customConfirmModal.style.display = 'none';
      okBtn.onclick = null;
      cancelBtn.onclick = null;
      resolve(result);
    };
    okBtn.onclick = () => handler(true);
    cancelBtn.onclick = () => handler(false);
  });
}

function showCustomPrompt(message, defaultValue = '', icon = 'ğŸ’¬') {
  return new Promise((resolve) => {
    document.getElementById('customPromptMessage').textContent = message;
    document.getElementById('customPromptIcon').textContent = icon;
    const input = document.getElementById('customPromptInput');
    input.value = defaultValue;
    customPromptModal.style.display = 'block';
    input.focus();
    const okBtn = document.getElementById('customPromptOk');
    const cancelBtn = document.getElementById('customPromptCancel');
    const handler = (result) => {
      customPromptModal.style.display = 'none';
      okBtn.onclick = null;
      cancelBtn.onclick = null;
      resolve(result);
    };
    okBtn.onclick = () => handler(input.value);
    cancelBtn.onclick = () => handler(null);
    input.onkeydown = (e) => { if(e.key === 'Enter') handler(input.value); };
  });
}

// Close modals on Escape
document.addEventListener('keydown', (e) => {
  if(e.key === 'Escape') {
    if(customAlertModal.style.display === 'block') customAlertModal.style.display = 'none';
    if(customConfirmModal.style.display === 'block') customConfirmModal.style.display = 'none';
    if(customPromptModal.style.display === 'block') customPromptModal.style.display = 'none';
  }
});

/* SETTINGS menu (gear) */
settingsBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  const open = settingsMenu.classList.toggle('show');
  settingsMenu.setAttribute('aria-hidden', !open);
  profileCard.classList.remove('show'); profileCard.setAttribute('aria-hidden','true');
  // hide how menu if open
  howMenu.classList.remove('show'); howMenu.setAttribute('aria-hidden','true');
});
settingsMenu.addEventListener('click', (e) => e.stopPropagation());
document.addEventListener('click', () => {
  if(settingsMenu.classList.contains('show')){
    settingsMenu.classList.remove('show');
    settingsMenu.setAttribute('aria-hidden','true');
  }
  if(profileCard.classList.contains('show')){
    profileCard.classList.remove('show');
    profileCard.setAttribute('aria-hidden','true');
  }
  // hide context menu too
  if(contextMenu.style.display === 'block') contextMenu.style.display = 'none';
  // hide How To panel
  if(howMenu.classList.contains('show')){ howMenu.classList.remove('show'); howMenu.setAttribute('aria-hidden','true'); }
});

/* Logout via settings */
settingsLogout.addEventListener('click', async () => {
  settingsMenu.classList.remove('show');
  const session = localStorage.getItem('session');
  if(session && !session.startsWith('Guest')) {
    try {
      await updateDoc(doc(db, 'users', session), { isOnline: false, lastSeen: serverTimestamp() });
    } catch(e) {}
  }
  localStorage.removeItem('session');
  showLogin();
});

/* Delete user via settings */
settingsDelete.addEventListener('click', async () => {
  settingsMenu.classList.remove('show');
  const session = localStorage.getItem('session');
  if(!session){ await showCustomAlert('No logged-in user'); return; }
  if(session.startsWith('Guest')){ await showCustomAlert('Guest account cannot be deleted.'); return; }
  const confirmed = await showCustomConfirm(`Delete your account and all stored credentials? This cannot be undone.`, 'âš ï¸');
  if(!confirmed) return;
  try{
    users = JSON.parse(localStorage.getItem('users')||'{}');

    // Get username before deletion for username mapping cleanup
    const userRef = doc(db, 'users', session);
    const userSnap = await getDoc(userRef);
    if(userSnap.exists()) {
      const userData = userSnap.data();
      const username = userData.username;

      // Delete username mapping
      if(username) {
        await deleteDoc(doc(db, 'usernames', username.toLowerCase())).catch(()=>{});
      }

      // Delete user document
      await deleteDoc(userRef);
    }

    // Update local users object (keyed by username in old format)
    for(const [key, val] of Object.entries(users)) {
      if(val === users[userSnap.data()?.username] || key === userSnap.data()?.username) {
        delete users[key];
      }
    }
    localStorage.setItem('users', JSON.stringify(users));
  }catch(e){}
  localStorage.removeItem('session');
  localStorage.removeItem('nick');
  showLogin();
});

/* Change Username via settings */
const settingsChangeUsername = document.getElementById('settingsChangeUsername');
const changeUsernameModal = document.getElementById('changeUsernameModal');
const cancelChangeUsername = document.getElementById('cancelChangeUsername');
const confirmChangeUsername = document.getElementById('confirmChangeUsername');
const newUsernameInput = document.getElementById('newUsername');
const currentPasswordForUsernameInput = document.getElementById('currentPasswordForUsername');
const changeUsernameMsg = document.getElementById('changeUsernameMsg');

settingsChangeUsername.addEventListener('click', async () => {
  settingsMenu.classList.remove('show');
  const session = localStorage.getItem('session');
  if(!session){ await showCustomAlert('No logged-in user'); return; }
  if(session.startsWith('Guest')){ await showCustomAlert('Guest accounts cannot change username.'); return; }
  changeUsernameModal.style.display = 'block';
  newUsernameInput.value = '';
  currentPasswordForUsernameInput.value = '';
  changeUsernameMsg.textContent = '';
});

cancelChangeUsername.addEventListener('click', () => {
  changeUsernameModal.style.display = 'none';
});

confirmChangeUsername.addEventListener('click', async () => {
  const currentSession = localStorage.getItem('session');
  const newUsername = newUsernameInput.value.trim();
  const currentPassword = currentPasswordForUsernameInput.value;

  if(!newUsername){ changeUsernameMsg.textContent = 'Please enter a new username.'; return; }
  if(newUsername === currentSession){ changeUsernameMsg.textContent = 'New username must be different.'; return; }
  if(newUsername.startsWith('Guest')){ changeUsernameMsg.textContent = 'Username cannot start with "Guest".'; return; }

  changeUsernameMsg.textContent = 'Checking...';

  try {
    // Verify current password - get user by UID
    const userRef = doc(db, 'users', currentSession);
    const snap = await getDoc(userRef);
    if(!snap.exists()){ changeUsernameMsg.textContent = 'Error: User not found.'; return; }

    const userData = snap.data();
    const currentPassHash = await sha256(currentPassword);
    if(userData.passwordHash !== currentPassHash){
      changeUsernameMsg.textContent = 'Wrong current password.';
      return;
    }

    // Check if new username is taken
    const existingUID = await getUIDFromUsername(newUsername);
    if(existingUID && existingUID !== currentSession){
      changeUsernameMsg.textContent = 'Username already taken.';
      return;
    }

    // Update user document with new username (preserve UID)
    await updateDoc(userRef, {
      username: newUsername
    });

    // Update username -> UID mapping (delete old, create new)
    const oldUsernameLower = (userData.username || '').toLowerCase();
    if(oldUsernameLower) {
      await deleteDoc(doc(db, 'usernames', oldUsernameLower)).catch(()=>{});
    }
    const newUsernameMappingRef = doc(db, 'usernames', newUsername.toLowerCase());
    await setDoc(newUsernameMappingRef, {
      uid: currentSession,
      username: newUsername,
      created: serverTimestamp()
    });

    // Clear UID cache for this user
    clearUIDCache(currentSession);

    // Update localStorage
    users = JSON.parse(localStorage.getItem('users')||'{}');
    const storedPassword = users[userData.username] || users[currentSession] || '';
    if(storedPassword) {
      delete users[userData.username];
      delete users[currentSession];
      users[newUsername] = storedPassword;
      localStorage.setItem('users', JSON.stringify(users));
    }
    localStorage.setItem('nick', newUsername);

    changeUsernameMsg.textContent = 'Username changed successfully!';
    setTimeout(() => {
      changeUsernameModal.style.display = 'none';
    }, 1500);

  } catch(err) {
    console.error(err);
    changeUsernameMsg.textContent = 'Error: ' + (err.message || String(err));
  }
});

/* Change Password via settings */
const settingsChangePassword = document.getElementById('settingsChangePassword');
const changePasswordModal = document.getElementById('changePasswordModal');
const cancelChangePassword = document.getElementById('cancelChangePassword');
const confirmChangePassword = document.getElementById('confirmChangePassword');
const currentPasswordInput = document.getElementById('currentPassword');
const newPasswordInput = document.getElementById('newPassword');
const confirmNewPasswordInput = document.getElementById('confirmNewPassword');
const changePasswordMsg = document.getElementById('changePasswordMsg');

settingsChangePassword.addEventListener('click', async () => {
  settingsMenu.classList.remove('show');
  const session = localStorage.getItem('session');
  if(!session){ await showCustomAlert('No logged-in user'); return; }
  if(session.startsWith('Guest')){ await showCustomAlert('Guest accounts cannot change password.'); return; }
  changePasswordModal.style.display = 'block';
  currentPasswordInput.value = '';
  newPasswordInput.value = '';
  confirmNewPasswordInput.value = '';
  changePasswordMsg.textContent = '';
});

cancelChangePassword.addEventListener('click', () => {
  changePasswordModal.style.display = 'none';
});

confirmChangePassword.addEventListener('click', async () => {
  const currentSession = localStorage.getItem('session');
  const currentPassword = currentPasswordInput.value;
  const newPassword = newPasswordInput.value;
  const confirmNewPassword = confirmNewPasswordInput.value;
  
  if(!currentPassword){ changePasswordMsg.textContent = 'Please enter current password.'; return; }
  if(!newPassword){ changePasswordMsg.textContent = 'Please enter new password.'; return; }
  if(newPassword !== confirmNewPassword){ changePasswordMsg.textContent = 'New passwords do not match.'; return; }
  if(newPassword.length < 4){ changePasswordMsg.textContent = 'Password must be at least 4 characters.'; return; }
  
  changePasswordMsg.textContent = 'Checking...';
  
  try {
    // Verify current password
    const userRef = doc(db, 'users', currentSession);
    const snap = await getDoc(userRef);
    if(!snap.exists()){ changePasswordMsg.textContent = 'Error: User not found.'; return; }
    
    const currentPassHash = await sha256(currentPassword);
    if(snap.data().passwordHash !== currentPassHash){ 
      changePasswordMsg.textContent = 'Wrong current password.'; 
      return; 
    }
    
    // Update password
    const newPassHash = await sha256(newPassword);
    await updateDoc(userRef, { passwordHash: newPassHash });
    
    // Update localStorage
    users = JSON.parse(localStorage.getItem('users')||'{}');
    users[currentSession] = newPassword;
    localStorage.setItem('users', JSON.stringify(users));
    
    changePasswordMsg.textContent = 'Password changed successfully!';
    setTimeout(() => {
      changePasswordModal.style.display = 'none';
    }, 1500);
    
  } catch(err) {
    console.error(err);
    changePasswordMsg.textContent = 'Error: ' + (err.message || String(err));
  }
});

/* Edit Room Description (Admin only) */
editDescriptionBtn.addEventListener('click', async () => {
  if(!isAdmin) {
    await showCustomAlert('Only the room admin can edit the description.', 'ğŸ”’');
    return;
  }
  
  // Fetch current description
  try {
    const roomRef = doc(db, 'rooms', room);
    const roomSnap = await getDoc(roomRef);
    if(roomSnap.exists()) {
      roomDescriptionInput.value = roomSnap.data().description || '';
    }
  } catch(e) {
    console.error('Error fetching room description:', e);
  }
  
  editDescriptionModal.style.display = 'block';
  editDescriptionMsg.textContent = '';
});

cancelEditDescription.addEventListener('click', () => {
  editDescriptionModal.style.display = 'none';
});

confirmEditDescription.addEventListener('click', async () => {
  if(!isAdmin) {
    editDescriptionMsg.textContent = 'Only admin can edit description.';
    return;
  }
  
  const newDescription = roomDescriptionInput.value.trim();
  
  try {
    const roomRef = doc(db, 'rooms', room);
    await updateDoc(roomRef, { description: newDescription });
    editDescriptionMsg.textContent = 'Description updated successfully!';
    setTimeout(() => {
      editDescriptionModal.style.display = 'none';
    }, 1500);
  } catch(e) {
    console.error('Error updating description:', e);
    editDescriptionMsg.textContent = 'Error updating description.';
  }
});

/* profile card show when hovering (desktop) or clicking (mobile) a name */
async function showProfileCardFor(name, color, joined, anchorEl){
  profileAvatar.textContent = name?.[0] || '?';
  profileAvatar.style.background = color || getComputedStyle(document.documentElement).getPropertyValue('--guest-gray').trim();
  profileName.textContent = name;
  profileColor.textContent = color || '';
  profileJoined.textContent = joined ? `Joined: ${new Date(joined).toLocaleDateString()}` : '';

  // Try to fetch user's description from Firestore
  let description = '';
  try {
    // Users collection uses UID as document ID, query by username field
    const usersRef = collection(db, 'users');
    const q = query(usersRef, where('username', '==', name), limit(1));
    const snapshot = await getDocs(q);
    if (!snapshot.empty) {
      description = snapshot.docs[0].data().description || '';
    }
  } catch (e) {
    // Fallback to localStorage
    description = localStorage.getItem(`profileDesc_${name}`) || '';
  }

  // Get the description element and update it
  const descEl = document.getElementById('profileCardDescription');
  if (descEl) {
    descEl.textContent = description;
    descEl.style.display = description ? 'block' : 'none';
  }

  if(anchorEl){
    const r = anchorEl.getBoundingClientRect();
    profileCard.style.top = (r.bottom + 8) + 'px';
    profileCard.style.right = Math.max(12, window.innerWidth - r.right) + 'px';
  }
  profileCard.classList.add('show'); profileCard.setAttribute('aria-hidden','false');
}

/* rooms load/render */
async function loadRooms(){
  roomList.innerHTML = '';
  roomListSidebar.innerHTML = '';
  roomListMobile.innerHTML = '';
  try{
    const s = await getDocs(collection(db,'rooms'));
    s.forEach(r => renderRoomEntry(r.id, r.data()));
  }catch(e){ console.error('loadRooms error', e); }
}

function renderRoomEntry(id, roomData = {}){
  const createEl = (container) => {
    const d = document.createElement('div');
    d.className = 'room';
    d.textContent = '# ' + id;
    d.onclick = ()=> joinRoom(id);
    
    // Add hover tooltip for description
    if(roomData.description) {
      d.addEventListener('mouseenter', (e) => {
        roomDescriptionText.textContent = roomData.description;
        roomDescriptionTooltip.style.display = 'block';
        const rect = d.getBoundingClientRect();
        roomDescriptionTooltip.style.left = rect.right + 10 + 'px';
        roomDescriptionTooltip.style.top = rect.top + 'px';
      });
      d.addEventListener('mouseleave', () => {
        roomDescriptionTooltip.style.display = 'none';
      });
    }
    
    container.appendChild(d);
  };
  createEl(roomList);
  createEl(roomListSidebar);
  createEl(roomListMobile);
}

/* NEW: real-time rooms listener so rooms appear immediately */
function setupRoomsListener(){
  if(roomsUnsub) roomsUnsub();
  try{
    const roomsCol = collection(db,'rooms');
    roomsUnsub = onSnapshot(roomsCol, snap => {
      roomList.innerHTML = '';
      roomListSidebar.innerHTML = '';
      roomListMobile.innerHTML = '';
      snap.forEach(docSnap => {
        renderRoomEntry(docSnap.id, docSnap.data());
      });
    }, err => {
      console.error('rooms listener error', err);
      // fallback to one-time load if realtime fails
      loadRooms().catch(()=>{});
    });
  }catch(e){
    console.error('setupRoomsListener error', e);
    loadRooms().catch(()=>{});
  }
}

/* Create Room Modal handlers */
createRoomBtn.onclick = () => {
  createRoomModal.style.display = 'block';
  newRoomName.value = '';
  newRoomPassword.value = '';
  newRoomDescription.value = '';
  createRoomMsg.textContent = '';
  newRoomName.focus();
};

cancelCreateRoom.addEventListener('click', () => {
  createRoomModal.style.display = 'none';
});

confirmCreateRoom.addEventListener('click', async () => {
  const r = newRoomName.value.trim();
  const p = newRoomPassword.value;
  const desc = newRoomDescription.value.trim();

  if(!r){
    createRoomMsg.textContent = 'Please enter a room name.';
    return;
  }

  createRoomMsg.textContent = 'Creating room...';

  try {
    const ref = doc(db,'rooms',r);
    const snap = await getDoc(ref);
    // Use session (UID) as admin identifier
    const currentUID = localStorage.getItem('session') || '';

    if(!snap.exists()) {
      // Create room with admins array (using UID)
      await setDoc(ref,{
        password:p,
        description:desc||'',
        created:serverTimestamp(),
        admins: [currentUID],
        bannedUsers: []
      });
    }

    createRoomModal.style.display = 'none';
    joinRoom(r);
  } catch(err) {
    console.error(err);
    createRoomMsg.textContent = 'Error: ' + (err.message || String(err));
  }
});

/* joinRoom handles mobile drawer smooth close when applicable, then calls enterRoom */
async function joinRoom(r){
  const ref = doc(db,'rooms',r);
  const snap = await getDoc(ref);
  if(!snap.exists()) { await showCustomAlert('Room not found', 'ğŸ”'); return; }

  const roomData = snap.data();

  // Check if user is banned (by UID)
  const currentUID = localStorage.getItem('session') || '';
  const bannedUsers = roomData.bannedUsers || [];
  if(bannedUsers.includes(currentUID)) {
    await showCustomAlert('You are banned from this room.', 'ğŸš«');
    return;
  }

  // Only ask for password if room has a password set
  if(roomData.password) {
    const pass = await showCustomPrompt('Enter room password:', '', 'ğŸ”');
    if(pass !== roomData.password) { await showCustomAlert('Wrong room password', 'âŒ'); return; }
  }

  // Check if current user is admin using UID (permanent account ID)
  isAdmin = (roomData.admin === currentUID);

  // Save nick/color
  nick = localStorage.getItem('nick') || ('Anon'+Math.floor(Math.random()*1000));
  const session = localStorage.getItem('session') || '';
  if(session.startsWith('Guest')){
    nickColor = getComputedStyle(document.documentElement).getPropertyValue('--guest-gray').trim() || '#9aa0a6';
  } else {
    nickColor = localStorage.getItem('nickColor') || '#58a6ff';
  }
  localStorage.setItem('nick', nick);
  localStorage.setItem('nickColor', nickColor);

  // If mobile & drawer open -> animate drawer close smoothly, THEN enter room
  const durationMs = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--drawer-duration')) || 200;
  const drawerOpen = mobileDrawer.classList.contains('show');
  if(isMobile && drawerOpen){
    mobileDrawer.classList.remove('show');
    mobileOverlay.classList.remove('show');
    setTimeout(()=> {
      mobileOverlay.style.display = 'none';
      mobileDrawer.style.display = 'none';
      enterRoom(r);
      updateOpenLobbyBtnVisibility();
    }, durationMs + 20);
  } else {
    enterRoom(r);
  }
}

/* Nick Color Picker handlers */
if(nickColorBtn) {
  nickColorBtn.onclick = () => {
    console.log('Color button clicked');
    nickColorModal.style.display = 'block';
    // Highlight current color
    const currentColor = localStorage.getItem('nickColor') || '#58a6ff';
    console.log('Current color:', currentColor);
    document.querySelectorAll('.color-option').forEach(opt => {
      if(opt.dataset.color === currentColor) {
        opt.style.borderColor = '#fff';
        opt.style.boxShadow = '0 0 10px ' + opt.dataset.color;
      } else {
        opt.style.borderColor = 'transparent';
        opt.style.boxShadow = 'none';
      }
    });
  };
}

if(cancelNickColor) {
  cancelNickColor.addEventListener('click', () => {
    nickColorModal.style.display = 'none';
  });
}

// Color option click handlers - using event delegation
document.addEventListener('click', async (e) => {
  if(e.target.classList.contains('color-option')) {
    const option = e.target;
    const selectedColor = option.dataset.color;
    console.log('Color selected:', selectedColor);
    const session = localStorage.getItem('session');

    // Save to localStorage
    localStorage.setItem('nickColor', selectedColor);
    nickColor = selectedColor;
    console.log('Color saved, nickColor:', nickColor);

    // Update user doc in Firebase if logged in (by UID)
    if(session && !session.startsWith('Guest')) {
      try {
        const userRef = doc(db, 'users', session);
        await updateDoc(userRef, { color: selectedColor });
        console.log('Color updated in Firestore');
      } catch(err) {
        console.error('Error saving color:', err);
      }
    }

    // Close modal
    nickColorModal.style.display = 'none';
  }
});

/* enterRoom performs the actual subscription and view switch */
async function enterRoom(r){
  showMain();
  room = r;
  roomName.textContent = '# ' + r;

  // Update user activity with new room
  updateUserActivity();

  // Fetch room data to get admin and check if current user is admin
  try {
    const roomRef = doc(db, 'rooms', r);
    const roomSnap = await getDoc(roomRef);
    if(roomSnap.exists()) {
      const roomData = roomSnap.data();
      // Support both legacy single admin and new multi-admin array
      if(Array.isArray(roomData.admins)) {
        roomAdmins = roomData.admins;
      } else if(roomData.admin) {
        roomAdmins = [roomData.admin];
      } else {
        roomAdmins = [];
      }
      // Check if current user is admin (in the roomAdmins array) using UID
      const currentUID = localStorage.getItem('session') || '';
      isAdmin = roomAdmins.includes(currentUID);
      // Show/hide edit description button
      if(editDescriptionBtn) {
        editDescriptionBtn.style.display = isAdmin ? 'inline-block' : 'none';
      }
    }
  } catch(e) {
    console.error('Error fetching room admin:', e);
  }

  // cleanup previous listeners
  if(messagesUnsub) messagesUnsub();
  if(typingUnsub) typingUnsub();

  // clear chat area
  chat.innerHTML = '';

  // Reload online users list if drawer is open (for when switching rooms)
  const drawer = document.getElementById('onlineUsersDrawer');
  if(drawer && drawer.style.transform === 'translateX(0px)') {
    loadOnlineUsersList();
  }
  lastMessageTime = Date.now();

  // incremental messages snapshot using docChanges
  const msgsQuery = query(collection(db,'rooms',room,'messages'), orderBy('time'));
  messagesUnsub = onSnapshot(msgsQuery, snap => {
    const shouldScroll = (chat.scrollHeight - chat.scrollTop - chat.clientHeight) < 160;
    snap.docChanges().forEach(change => {
      const d = change.doc;
      const m = d.data();
      if(change.type === 'added'){
        renderMessage(d.id, m);
        // Show notification for new messages from others
        const localNick = localStorage.getItem('nick') || nick;
        const notificationsEnabled = localStorage.getItem('notificationsEnabled') === 'true';
        if(m.name !== localNick && m.name !== 'System' && 'Notification' in window && Notification.permission === 'granted' && document.hidden && notificationsEnabled) {
          const notif = new Notification('New message in #' + room, {
            body: m.name + ': ' + (m.text.length > 60 ? m.text.substring(0, 60) + '...' : m.text),
            icon: 'images/echo_space_favicon.png',
            tag: 'echo-message-' + d.id
          });
          notif.onclick = () => {
            window.focus();
            notif.close();
          };
        }
        // mark as seen for this user (only for new messages)
        if(localNick){
          setDoc(doc(db, 'rooms', room, 'messages', d.id, 'seen', localNick), {name: localNick, t: serverTimestamp()}).catch(()=>{});
        }
      } else if(change.type === 'modified'){
        updateMessage(d.id, m);
      } else if(change.type === 'removed'){
        removeMessage(d.id);
      }
    });
    // use RAF to make autoscroll robust (fixes missed scrolls)
    requestAnimationFrame(() => { scrollChatToBottom(); updateScrollBottomBtnVisibility(); });
  });

  // typing snapshot (robust handling of timestamp field)
  typingUnsub = onSnapshot(collection(db,'rooms',room,'typing'), snap => {
    const now = Date.now();
    const usersTyping = [];
    snap.forEach(d=> {
      if(d.id === (localStorage.getItem('nick')||nick)) return; // skip self
      const tField = d.data().t;
      let tMs = null;
      if(tField && typeof tField.toMillis === 'function') tMs = tField.toMillis();
      else if(typeof tField === 'number') tMs = tField;
      else if(tField && typeof tField._seconds === 'number') tMs = (tField._seconds*1000) + (tField._nanoseconds ? Math.floor(tField._nanoseconds/1e6) : 0);
      if(tMs && (now - tMs) < 4000) usersTyping.push(d.id);
    });

    // render stylish indicator (with controlled animation restarts)
    renderTypingIndicator(usersTyping);
  });

  // Auto-scroll to bottom after a short delay to ensure messages are loaded
  setTimeout(() => {
    scrollChatToBottom(true);
    updateScrollBottomBtnVisibility();
  }, 500);
}

/* --- Animation restart control vars:
   We avoid restarting the dot animation on every typing heartbeat (otherwise it's too snappy).
   Restart only when the set of users changes OR if enough time has passed since last restart.
*/
let _lastTypingKey = '';
let _lastTypingAnimRestart = 0;
const TYPING_ANIM_MIN_RESTART_INTERVAL = 1200; // ms; don't restart animation more often than this unless users changed

/* renderTypingIndicator: shows avatars + animated dots + text (up to 4 users)
   Uses userCache for colors where possible; falls back to guest gray.
   Animation will be restarted only when users list changes OR minimum interval elapsed.
*/
function renderTypingIndicator(usersTyping){
  if(!usersTyping || usersTyping.length === 0){
    typingIndicator.style.display = 'none';
    _lastTypingKey = '';
    return;
  }

  typingIndicator.style.display = 'flex';

  const avatarsWrap = typingIndicator.querySelector('.typing-avatars');
  const label = typingIndicator.querySelector('.typing-label');

  // muodostetaan avain nykyisestÃ¤ typing-tilasta
  const typingKey = usersTyping.join('|');

  /*
    AVATARIT:
    Rakenna avatarit vain jos typing-kokoonpano on OIKEASTI muuttunut
    â†’ estÃ¤Ã¤ animaation uudelleenkÃ¤ynnistymisen
  */
  if (typingKey !== _lastTypingKey) {
    avatarsWrap.innerHTML = usersTyping.slice(0,4).map(n=>{
      const color =
        (userCache.get(n)?.color) ||
        getComputedStyle(document.documentElement)
          .getPropertyValue('--guest-gray').trim();

      return `<div class="typ-av" style="background:${color}">
        ${escapeHtml((n || '?')[0])}
      </div>`;
    }).join('');

    _lastTypingKey = typingKey;
  }

  // LABEL (saa pÃ¤ivittyÃ¤ JOKA KERTA, ei kÃ¤ynnistÃ¤ animaatiota)
  if(usersTyping.length === 1)
    label.textContent = `${usersTyping[0]} is typing`;
  else if(usersTyping.length === 2)
    label.textContent = `${usersTyping[0]} and ${usersTyping[1]} are typing`;
  else if(usersTyping.length === 3)
    label.textContent = `${usersTyping[0]}, ${usersTyping[1]} and ${usersTyping[2]} are typing`;
  else
    label.textContent = `${usersTyping[0]}, ${usersTyping[1]} and ${usersTyping.length - 2} others are typing`;
}

/* Reactions functionality */
const currentReactions = new Map(); // msgId -> {emoji -> Set of usernames}

function setupReactionsListener(msgId, el){
  const reactionsRef = collection(db, 'rooms', room, 'messages', msgId, 'reactions');
  const unsubscribe = onSnapshot(reactionsRef, (snapshot) => {
    const reactions = new Map();
    snapshot.forEach((doc) => {
      const data = doc.data();
      const emoji = data.emoji;
      const username = data.name;
      if(!reactions.has(emoji)) reactions.set(emoji, new Set());
      reactions.get(emoji).add(username);
    });
    currentReactions.set(msgId, reactions);
    renderReactions(msgId, el, reactions);
  });
  
  // Store unsubscribe function on element for cleanup
  el._reactionsUnsubscribe = unsubscribe;
}

function renderReactions(msgId, el, reactions){
  const container = el.querySelector('.reactions-container');
  if(!container) return;
  
  const localNick = localStorage.getItem('nick') || nick;
  container.innerHTML = '';
  
  reactions.forEach((users, emoji) => {
    const btn = document.createElement('div');
    btn.className = 'reaction-btn';
    if(users.has(localNick)) btn.classList.add('active');
    btn.innerHTML = `<span class="emoji">${emoji}</span><span class="count">${users.size}</span>`;
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleReaction(msgId, emoji);
    });
    container.appendChild(btn);
  });
  
  // Always show add-reaction button at the end
  if(!isMobile){
    const addBtn = document.createElement('div');
    addBtn.className = 'add-reaction-btn';
    addBtn.title = 'Add reaction';
    addBtn.textContent = '+';
    addBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      showReactionPicker(msgId, addBtn);
    });
    container.appendChild(addBtn);
  }
}

async function toggleReaction(msgId, emoji){
  const now = Date.now();
  const localNick = localStorage.getItem('nick') || nick;
  const reactionRef = doc(db, 'rooms', room, 'messages', msgId, 'reactions', localNick);

  try {
    const existing = await getDoc(reactionRef);
    if(existing.exists() && existing.data().emoji === emoji){
      // Remove reaction if clicking the same emoji
      await deleteDoc(reactionRef);
    } else {
      // Add or change reaction
      await setDoc(reactionRef, { 
        emoji: emoji, 
        name: localNick, 
        time: serverTimestamp() 
      });
    }
  } catch(e) {
    console.error('Error toggling reaction:', e);
  }
}

let currentReactionMsgId = null;

function showReactionPicker(msgId, triggerEl){
  currentReactionMsgId = msgId;
  const rect = triggerEl.getBoundingClientRect();
  
  // Get picker dimensions
  const pickerWidth = 280;
  const pickerHeight = 200;
  
  // Calculate position
  let left = rect.left;
  let top = rect.bottom + 8;
  
  // Adjust if picker would go off-screen horizontally
  if(left + pickerWidth > window.innerWidth) {
    left = window.innerWidth - pickerWidth - 20;
  }
  if(left < 10) {
    left = 10;
  }
  
  // Adjust if picker would go off-screen vertically
  if(top + pickerHeight > window.innerHeight) {
    top = rect.top - pickerHeight - 8;
  }
  
  reactionPicker.style.left = left + 'px';
  reactionPicker.style.top = top + 'px';
  reactionPicker.classList.add('show');
  reactionPicker.setAttribute('aria-hidden', 'false');
}

function hideReactionPicker(){
  reactionPicker.classList.remove('show');
  reactionPicker.setAttribute('aria-hidden', 'true');
  currentReactionMsgId = null;
}

// Reaction picker click handlers
reactionPicker.querySelectorAll('.emoji-option').forEach(btn => {
  btn.addEventListener('click', async (e) => {
    e.stopPropagation();
    if(currentReactionMsgId){
      await toggleReaction(currentReactionMsgId, btn.dataset.emoji);
      hideReactionPicker();
    }
  });
});

// Hide reaction picker when clicking outside
document.addEventListener('click', (e) => {
  if(!reactionPicker.contains(e.target) && !e.target.closest('.add-reaction-btn')){
    hideReactionPicker();
  }
});

/* DOM helpers for incremental updates */
function makeMessageElement(id, m){
  const el = document.createElement('div');
  el.className = 'message';
  el.dataset.msgid = id;
  el.dataset.owner = m.name;

  // Resolve UID to current username if present
  const displayName = m.name;
  const messageUID = m.uid || m.session;

  const replyHtml = m.reply?`<div class="reply-preview" data-reply-msgid="${escapeAttr(m.reply.msgId || '')}"><b>${escapeHtml(m.reply.name)}</b>: ${escapeHtml(m.reply.text)}</div>`:'';

  // Handle GIF messages
  let contentHtml = '';
  if(m.gif){
    contentHtml = `<div class="gif-container"><img src="${escapeAttr(m.gif)}" alt="GIF" loading="lazy" onclick="window.open('${escapeAttr(m.gif)}', '_blank')"></div>`;
  } else {
    contentHtml = linkify(escapeHtml(m.text || ''));
  }
  const safeTextHtml = contentHtml;
  const editedNoteHtml = m.editedNote ? `<span class="edited-note">${escapeHtml(m.editedNote)}</span>` : '';

  // Update reply button data-text to handle GIFs
  const replyText = m.gif ? '[GIF]' : (m.text || '');

  // Check if sender is admin by checking if UID is in roomAdmins array
  const isSenderAdmin = messageUID ? roomAdmins.includes(messageUID) : false;
  const adminBadge = isSenderAdmin ? '<span style="background:var(--accent);color:#000;font-size:10px;margin-left:6px;padding:2px 8px;border-radius:4px;font-weight:700;text-transform:uppercase;letter-spacing:0.5px;display:inline-flex;align-items:center;gap:3px"><span style="font-size:9px">ğŸ‘‘</span>ADMIN</span>' : '';

  // Build inner message WITHOUT reply button when mobile.
  // Role badges will be added asynchronously to prevent duplicates
  let msgInner = `
    <div class="avatar" style="background:${m.color || getComputedStyle(document.documentElement).getPropertyValue('--guest-gray').trim()}">${escapeHtml((displayName||'?')[0]||'?')}</div>
    <div class="msg">
      ${replyHtml}
      <b class="msg-sender" style="color:${m.color || '#999'};cursor:pointer">${escapeHtml(displayName)}</b>${adminBadge}
      <span class="time">${m.time?.toMillis ? new Date(m.time.toMillis()).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}) : ''}</span>
      <div class="msg-text">${safeTextHtml}${editedNoteHtml}</div>
      <div class="reactions-container" data-msgid="${id}"></div>
    </div>
  `;

  el.innerHTML = msgInner;

  // Add reply button ONLY for non-mobile (desktop)
  if(!isMobile){
    const replyBtn = document.createElement('div');
    replyBtn.className = 'reply-btn';
    replyBtn.setAttribute('data-name', escapeAttr(displayName));
    replyBtn.setAttribute('data-text', escapeAttr(replyText));
    replyBtn.textContent = 'reply';
    el.querySelector('.msg').appendChild(replyBtn);
  }

  // Add the three-dot MORE button for own messages (desktop only)
  const localNick = localStorage.getItem('nick') || nick;
  if(displayName === localNick && !isMobile){
    const msgInnerEl = el.querySelector('.msg');
    const moreBtn = document.createElement('div');
    moreBtn.className = 'more-btn';
    moreBtn.title = 'More';
    moreBtn.textContent = 'â‹¯';
    moreBtn.addEventListener('click', (ev) => {
      ev.stopPropagation();
      const rect = moreBtn.getBoundingClientRect();
      // show the same context menu but positioned near the button
      showEditDeleteMenu(Math.round(rect.left + 8), Math.round(rect.bottom + 6), id, m.text);
    });
    msgInnerEl.appendChild(moreBtn);
  }

  // Set up real-time listener for reactions (also adds the add-reaction button)
  setupReactionsListener(id, el);

  // Fetch and cache user role for this message
  (async () => {
    try {
      // Use UID to look up user data if available
      const userIdentifier = messageUID || displayName;
      const cached = userCache.get(userIdentifier);
      // Look up user by UID if we have it
      let userDocId = messageUID;
      if(!userDocId && !displayName.startsWith('Guest')) {
        userDocId = await getUIDFromUsername(displayName);
      }
      if(userDocId) {
        const us = await getDoc(doc(db,'users',userDocId));
        if(us.exists()) {
          const ud = us.data();
          const role = ud.role || null;
          userCache.set(userIdentifier, { ...(cached || {}), role, color: ud.color || m.color });
          // Update role badge if role exists (admins can have both admin and role badges)
          if(role && ROLES[role]) {
            const senderEl = el.querySelector('.msg-sender');
            if(senderEl && el.isConnected) {
              // Remove any existing role badges first
              const existingRoleBadges = senderEl.parentElement.querySelectorAll('[data-role-badge]');
              existingRoleBadges.forEach(badge => badge.remove());
              // Add the role badge after the sender name
              const roleBadgeEl = document.createElement('span');
              roleBadgeEl.dataset.roleBadge = 'true';
              roleBadgeEl.innerHTML = getRoleBadge(role);
              senderEl.insertAdjacentElement('afterend', roleBadgeEl);
            }
          }
        }
      }
    } catch(e) {}
  })();

  // attach interactions
  const senderEl = el.querySelector('.msg-sender');
  if(senderEl){
    if(!isMobile){
      senderEl.addEventListener('mouseenter', async (ev)=>{
        ev.stopPropagation();
        let joined = null; let color = m.color;
        try{
          const userIdentifier = messageUID || displayName;
          const cached = userCache.get(userIdentifier);
          if(cached && cached.color) color = cached.color;
          else {
            // Look up by UID if available
            let userDocId = messageUID;
            if(!userDocId && !displayName.startsWith('Guest')) {
              userDocId = await getUIDFromUsername(displayName);
            }
            if(userDocId) {
              const us = await getDoc(doc(db,'users',userDocId));
              if(us.exists()){
                const ud = us.data();
                joined = ud.joined?.toMillis ? new Date(ud.joined.toMillis()) : ud.joined;
                color = ud.color || color;
                const role = ud.role || null;
                userCache.set(userIdentifier, { color, role });
              }
            }
          }
        }catch(e){}
        showProfileCardFor(displayName, color, joined, senderEl);
      });
      senderEl.addEventListener('mouseleave', ()=>{
        setTimeout(()=>{ if(!senderEl.matches(':hover') && !profileCard.matches(':hover')) { profileCard.classList.remove('show'); profileCard.setAttribute('aria-hidden','true'); } }, 200);
      });
    } else {
      senderEl.addEventListener('click', async (ev)=>{
        ev.stopPropagation();
        let joined = null; let color = m.color;
        try{
          const userIdentifier = messageUID || displayName;
          const cached = userCache.get(userIdentifier);
          if(cached && cached.color) color = cached.color;
          else {
            let userDocId = messageUID;
            if(!userDocId && !displayName.startsWith('Guest')) {
              userDocId = await getUIDFromUsername(displayName);
            }
            if(userDocId) {
              const us = await getDoc(doc(db,'users',userDocId));
              if(us.exists()){
                const ud = us.data();
                joined = ud.joined?.toMillis ? new Date(ud.joined.toMillis()) : ud.joined;
                color = ud.color || color;
                const role = ud.role || null;
                userCache.set(userIdentifier, { color, role });
              }
            }
          }
        }catch(e){}
        showProfileCardFor(displayName, color, joined, senderEl);
      });
    }
  }

  // hover to show who has seen this message
  el.addEventListener('mouseenter', async (ev)=>{
    if(displayName === (localStorage.getItem('nick')||nick)) return;
    const rect = el.getBoundingClientRect();
    tooltip.style.left = (rect.right + 8) + 'px';
    tooltip.style.top = (rect.top) + 'px';
    tooltip.textContent = 'Loading...';
    tooltip.style.display = 'block';
    tooltip.setAttribute('aria-hidden','false');
    try{
      const seenDocs = await getDocs(collection(db, 'rooms', room, 'messages', id, 'seen'));
      const names = [];
      seenDocs.forEach(sd=> names.push(sd.data().name));
      tooltip.textContent = names.length ? ('Seen by: ' + names.join(', ')) : 'No one has seen this yet';
    }catch(e){ tooltip.textContent = 'â€”'; }
  });
  el.addEventListener('mouseleave', ()=>{ tooltip.style.display = 'none'; tooltip.setAttribute('aria-hidden','true'); });

  // attach mobile interactions including swipe-to-reply and long-press edit/delete
  attachMobileInteractions(el, id, m);

  // reply button click handler (desktop only)
  el.querySelectorAll('.reply-btn').forEach(b => b.addEventListener('click', (e)=>{
    replyTo = { name: b.dataset.name, text: b.dataset.text, msgId: id };
    replyBox.style.display = 'block';
    replyBox.innerHTML = `Replying to <b>${escapeHtml(replyTo.name)}</b> <button id="cancelReply" style="margin-left:8px">x</button>`;
    const btn = document.getElementById('cancelReply'); if(btn) btn.onclick = cancelReply;
  }));

  // reply preview click handler - scroll to original message
  el.querySelectorAll('.reply-preview').forEach(rp => {
    rp.addEventListener('click', (e) => {
      e.stopPropagation();
      const replyMsgId = rp.dataset.replyMsgid;
      if(replyMsgId) {
        const originalMsg = chat.querySelector(`[data-msgid="${replyMsgId}"]`);
        if(originalMsg) {
          originalMsg.scrollIntoView({ behavior: 'smooth', block: 'center' });
          // Add highlight effect
          originalMsg.style.background = 'rgba(88,166,255,0.1)';
          setTimeout(() => {
            originalMsg.style.background = '';
          }, 1500);
        }
      }
    });
  });

  return el;
}

function renderMessage(id, m){
  // skip if already exists
  if(chat.querySelector(`[data-msgid="${id}"]`)) return;
  const el = makeMessageElement(id, m);
  chat.appendChild(el);
}

function updateMessage(id, m){
  const el = chat.querySelector(`[data-msgid="${id}"]`);
  if(!el) { renderMessage(id, m); return; }
  const replyHtml = m.reply?`<div class="reply-preview"><b>${escapeHtml(m.reply.name)}</b>: ${escapeHtml(m.reply.text)}</div>`:'';

  // Handle GIF updates
  let contentHtml = '';
  if(m.gif){
    contentHtml = `<div class="gif-container"><img src="${escapeAttr(m.gif)}" alt="GIF" loading="lazy" onclick="window.open('${escapeAttr(m.gif)}', '_blank')"></div>`;
  } else {
    contentHtml = linkify(escapeHtml(m.text || ''));
  }
  const safeTextHtml = contentHtml;
  const editedNoteHtml = m.editedNote ? `<span class="edited-note">${escapeHtml(m.editedNote)}</span>` : '';
  const avatar = el.querySelector('.avatar');
  const sender = el.querySelector('.msg-sender');
  const time = el.querySelector('.time');
  const msgText = el.querySelector('.msg-text');
  if(avatar) avatar.style.background = m.color || getComputedStyle(document.documentElement).getPropertyValue('--guest-gray').trim();
  if(sender) {
    sender.textContent = m.name;
    sender.style.color = m.color || '#999';
    // Update admin badge using UID (check if in roomAdmins array)
    const messageUID = m.uid || m.session;
    const isSenderAdmin = messageUID ? roomAdmins.includes(messageUID) : false;
    // Remove existing admin and role badges
    let nextEl = sender.nextElementSibling;
    while(nextEl && (nextEl.style.background === 'var(--accent)' || nextEl.dataset.roleBadge)) {
      const toRemove = nextEl;
      nextEl = nextEl.nextElementSibling;
      toRemove.remove();
    }
    // Add admin badge if admin
    if(isSenderAdmin) {
      const adminBadge = document.createElement('span');
      adminBadge.style.cssText = 'background:var(--accent);color:#000;font-size:10px;margin-left:6px;padding:2px 8px;border-radius:4px;font-weight:700;text-transform:uppercase;letter-spacing:0.5px;display:inline-flex;align-items:center;gap:3px';
      adminBadge.innerHTML = '<span style="font-size:9px">ğŸ‘‘</span>ADMIN';
      sender.after(adminBadge);
    }
    // Add role badge if cached (admins can have both admin and role badges)
    const userIdentifier = messageUID || m.name;
    const cached = userCache.get(userIdentifier);
    if(cached && cached.role && ROLES[cached.role]) {
      const roleBadge = document.createElement('span');
      roleBadge.dataset.roleBadge = 'true';
      roleBadge.innerHTML = getRoleBadge(cached.role);
      sender.after(roleBadge);
    }
  }

  // Fetch and cache user role
  (async () => {
    try {
      const userIdentifier = messageUID || m.name;
      const cached = userCache.get(userIdentifier);
      // Look up by UID if available
      let userDocId = messageUID;
      if(!userDocId && !m.name.startsWith('Guest')) {
        userDocId = await getUIDFromUsername(m.name);
      }
      if(userDocId) {
        const us = await getDoc(doc(db,'users',userDocId));
        if(us.exists()) {
          const ud = us.data();
          const role = ud.role || null;
          // Update cache with fresh role data
          userCache.set(userIdentifier, { ...(cached || {}), role });

          // Update role badge if element still exists
          if(el.isConnected) {
            const senderEl = el.querySelector('.msg-sender');
            if(senderEl) {
              // Remove existing role badge first (prevents duplicates)
              const existingRoleBadges = senderEl.parentElement.querySelectorAll('[data-role-badge]');
              existingRoleBadges.forEach(badge => badge.remove());

              // Add new role badge if role exists (admins can have both admin and role badges)
              if(role && ROLES[role]) {
                const roleBadgeEl = document.createElement('span');
                roleBadgeEl.dataset.roleBadge = 'true';
                roleBadgeEl.innerHTML = getRoleBadge(role);
                senderEl.insertAdjacentElement('afterend', roleBadgeEl);
              }
            }
          }
        }
      }
    } catch(e) {}
  })();
  if(time) time.textContent = m.time?.toMillis ? new Date(m.time.toMillis()).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}) : '';
  if(msgText) msgText.innerHTML = safeTextHtml + editedNoteHtml;
  // reply preview update
  const replyPrev = el.querySelector('.reply-preview');
  if(replyPrev && !m.reply) replyPrev.remove();
  else if(!replyPrev && m.reply) el.querySelector('.msg').insertAdjacentHTML('afterbegin', replyHtml);

  // ensure more-btn exists for own messages (desktop only)
  const localNick = localStorage.getItem('nick') || nick;
  const hasMore = !!el.querySelector('.more-btn');
  if(m.name === localNick && !isMobile && !hasMore){
    const msgInner = el.querySelector('.msg');
    const moreBtn = document.createElement('more-btn');
    // create proper more button (kept consistent)
    const mb = document.createElement('div');
    mb.className = 'more-btn';
    mb.title = 'More';
    mb.textContent = 'â‹¯';
    mb.addEventListener('click', (ev) => {
      ev.stopPropagation();
      const rect = mb.getBoundingClientRect();
      showEditDeleteMenu(Math.round(rect.left + 8), Math.round(rect.bottom + 6), id, m.text);
    });
    msgInner.appendChild(mb);
  } else if((m.name !== localNick || isMobile) && hasMore){
    const mb = el.querySelector('.more-btn');
    if(mb) mb.remove();
  }
}

function removeMessage(id){
  const el = chat.querySelector(`[data-msgid="${id}"]`);
  if(el) el.remove();
}

/* context menu implementation (dropdown on three-dots / replaced right-click / long-press) */
function showEditDeleteMenu(x,y,msgId, currentText){
  contextMenu.innerHTML = '';
  // Edit
  const editBtn = document.createElement('button');
  editBtn.textContent = 'Edit';
  editBtn.onclick = async (ev)=>{
    ev.stopPropagation();
    const newText = await showCustomPrompt('Edit message:', currentText, 'âœï¸');
    if(newText == null) { hideContextMenu(); return; }
    try{ await updateDoc(doc(db,'rooms',room,'messages',msgId), { text: newText, editedNote: 'Edited' }).catch(console.error); }catch(e){}
    hideContextMenu();
  };
  contextMenu.appendChild(editBtn);
  // React
  const reactBtn = document.createElement('button');
  reactBtn.textContent = 'React';
  reactBtn.onclick = async (ev)=>{
    ev.stopPropagation();
    hideContextMenu();
    // Show reaction picker near the message
    const msgEl = chat.querySelector(`[data-msgid="${msgId}"]`);
    if(msgEl){
      const addReactionBtn = msgEl.querySelector('.add-reaction-btn');
      if(addReactionBtn){
        showReactionPicker(msgId, addReactionBtn);
      }
    }
  };
  contextMenu.appendChild(reactBtn);
  // Delete
  const delBtn = document.createElement('button');
  delBtn.textContent = 'Delete';
  delBtn.onclick = async (ev)=>{
    ev.stopPropagation();
    const confirmed = await showCustomConfirm('Delete this message?', 'ğŸ—‘ï¸');
    if(confirmed){
      try{ await deleteDoc(doc(db,'rooms',room,'messages',msgId)).catch(console.error); }catch(e){}
    }
    hideContextMenu();
  };
  contextMenu.appendChild(delBtn);

  // position
  const pad = 6;
  const menuWidth = 180;
  const menuHeight = 80;
  let left = x;
  let top = y;
  if(left + menuWidth > window.innerWidth) left = window.innerWidth - menuWidth - pad;
  if(top + menuHeight > window.innerHeight) top = window.innerHeight - menuHeight - pad;
  contextMenu.style.left = left + 'px';
  contextMenu.style.top = top + 'px';
  contextMenu.style.display = 'block';
  contextMenu.setAttribute('aria-hidden','false');
}
function hideContextMenu(){
  contextMenu.style.display = 'none';
  contextMenu.setAttribute('aria-hidden','true');
}

/* MOBILE INTERACTIONS: simplified/no-op (mobile support disabled)
   attachMobileInteractions kept as function with same signature, but it now
   performs no touch handling because isMobile is false and we removed the
   unused mobile touch/drag code to keep the bundle lean.
*/
function attachMobileInteractions(el, msgId, messageData){
  // mobile support intentionally disabled; keep function for compatibility
  if(!isMobile) return;
  // (no further code â€” previously heavy touch handlers removed)
}

/* typing indicator management (client writes typing docs elsewhere) */
msg.addEventListener('input', ()=> {
  if(!room || !nick) return;
  if(msg.value.trim()===''){
    deleteDoc(doc(db,'rooms',room,'typing',localStorage.getItem('nick')||nick)).catch(()=>{});
    return;
  }
  setDoc(doc(db,'rooms',room,'typing',localStorage.getItem('nick')||nick),{t:serverTimestamp()});
  clearTimeout(typingTimeout);
  typingTimeout = setTimeout(()=> { deleteDoc(doc(db,'rooms',room,'typing',localStorage.getItem('nick')||nick)).catch(()=>{}); }, 1500);
});
msg.addEventListener('blur', ()=> { if(room && (localStorage.getItem('nick')||nick)) deleteDoc(doc(db,'rooms',room,'typing',localStorage.getItem('nick')||nick)).catch(()=>{}); });

/* reply UI */
chat.addEventListener('click', (e)=>{
  const b = e.target.closest('.reply-btn');
  if(!b) return;
  replyTo = { name: b.dataset.name, text: b.dataset.text, msgId: chat.querySelector(`[data-msgid="${b.closest('.message').dataset.msgid}"]`)?.dataset.msgid || '' };
  replyBox.style.display = 'block';
  replyBox.innerHTML = `Replying to <b>${escapeHtml(replyTo.name)}</b> <button id="cancelReply" style="margin-left:8px">x</button>`;
  document.getElementById('cancelReply').onclick = cancelReply;
});
function cancelReply(){ replyTo = null; replyBox.style.display = 'none'; }

chat.addEventListener('scroll', updateScrollBottomBtnVisibility);

function updateScrollBottomBtnVisibility(){
  const isAtBottom = chat.scrollHeight - chat.scrollTop - chat.clientHeight < 160;
  scrollBottomBtn.style.display = isAtBottom ? 'none' : 'block';
}

scrollBottomBtn.addEventListener('click', () => scrollChatToBottom(true));

/* send messages */
msg.addEventListener('keydown', async (e)=>{
  if(e.key === 'ArrowUp' && msg.value === '') {
    e.preventDefault();
    console.log('ArrowUp pressed, lastOwnMessage:', lastOwnMessage);
    msg.value = lastOwnMessage;
    return;
  }
  if(e.key !== 'Enter') return;
  const textRaw = msg.value.trim(); msg.value = ''; if(!textRaw) return;
  lastOwnMessage = textRaw;
  console.log('Message sent, saved lastOwnMessage:', lastOwnMessage);
  if(!room){ await showCustomAlert('You are not in a room', 'ğŸšª'); return; }

  // Check if user is banned before sending (by UID)
  const currentUID = localStorage.getItem('session') || '';
  try {
    const roomRef = doc(db, 'rooms', room);
    const roomSnap = await getDoc(roomRef);
    if(roomSnap.exists()) {
      const roomData = roomSnap.data();
      const bannedUsers = roomData.bannedUsers || [];
      if(bannedUsers.includes(currentUID)) {
        await showCustomAlert('You are banned from this room.', 'ğŸš«');
        return;
      }
    }
  } catch(e) {
    console.error('Error checking ban status:', e);
  }

  deleteDoc(doc(db,'rooms',room,'typing',localStorage.getItem('nick')||nick)).catch(()=>{});

  // Commands handling
  if(textRaw.startsWith('/')){
    await handleCommand(textRaw);
    return;
  }

  // compute color deterministically
  const colorToSend = (localStorage.getItem('session') && !localStorage.getItem('session').startsWith('Guest')) ? (localStorage.getItem('nickColor') || '#58a6ff') : getComputedStyle(document.documentElement).getPropertyValue('--guest-gray').trim();

  await addDoc(collection(db,'rooms',room,'messages'), {
    name: localStorage.getItem('nick') || nick,
    uid: localStorage.getItem('session') || '',
    text: textRaw,
    reply: replyTo,
    color: colorToSend,
    time: serverTimestamp()
  }).catch(console.error);
  replyTo = null; replyBox.style.display = 'none';
});

/* Helper: robust autoscroll (used after updates) */
function scrollChatToBottom(force = false){
  if(force){
    chat.scrollTop = chat.scrollHeight;
    return;
  }
  const nearBottom = chat.scrollHeight - chat.scrollTop - chat.clientHeight < 160;
  if(nearBottom){
    chat.scrollTop = chat.scrollHeight;
  }
}

/* Helper: chunked batch deletes (handles >500 deletes safely) */
async function deleteDocsInBatches(refs){
  const CHUNK = 400; // safe chunk under Firestore limit
  let i = 0;
  while(i < refs.length){
    const b = writeBatch(db);
    const end = Math.min(i + CHUNK, refs.length);
    for(let j=i;j<end;j++) b.delete(refs[j]);
    await b.commit();
    i = end;
  }
}

/* command processor */
async function handleCommand(cmdText){
  const parts = cmdText.split(/\s+/);
  const c = parts[0].toLowerCase();
  // help: visible only to you -> show via alert
  if(c === '/help'){
    const helpText = [
      "Commands:",
      "/help â€” Show this list (only visible to you).",
      "/roll [n] â€” Roll 1â€“10 dice (default 1).",
      "/coin â€” Flip a coin.",
      "/tableflip â€” Table flip effect.",
      "/shrug â€” Â¯\\_(ãƒ„)_/Â¯",
      "/clear â€” Delete all messages (Admin only).",
      "/delete (or /delet) â€” Delete the room (Admin only).",
      "/giveadmin <username> â€” Give admin rights to a user (Admin only).",
      "/ban <username> â€” Ban a user from the room (Admin only).",
      "/unban <username> â€” Unban a user from the room (Admin only).",
      "/banned â€” List banned users (Admin only).",
      "/roles â€” Open the role selector to choose a role badge.",
      "",
      "Room Admin:",
      "- The user who creates a room becomes the Admin",
      "- Admin can delete the room and clear all messages",
      "- Admin can give admin rights to other users",
      "- Admin can ban users from the room",
      "- Admin has ğŸ‘‘ ADMIN badge next to their name",
      "",
      "Roles:",
      "- Use /roles to choose a role badge for your profile",
      "- Roles are displayed next to your name in chat"
    ].join("\n\n");
    await showCustomAlert(helpText, 'ğŸ“–');
    return;
  }

  if(c === '/roll'){
    let n = 1; if(parts[1]) n = Math.min(10, Math.max(1, parseInt(parts[1])||1));
    const rolls = [];
    for(let i=0;i<n;i++) rolls.push(Math.floor(Math.random()*6)+1);
    const txt = `${localStorage.getItem('nick')||nick} rolled ğŸ² ${rolls.map(r=>`ğŸ² ${r}`).join(n>1?' + ':'')}${n>1?` = ${rolls.reduce((a,b)=>a+b,0)}`:''}`;
    await addDoc(collection(db,'rooms',room,'messages'), {name:'System', text:txt, color:'#888', time:serverTimestamp()});
    return;
  }
  if(c === '/coin'){
    const r = Math.random() < 0.5 ? 'Heads' : 'Tails';
    const txt = `${localStorage.getItem('nick')||nick} flipped a coin â†’ ${r}`;
    await addDoc(collection(db,'rooms',room,'messages'), {name:'System', text:txt, color:'#888', time:serverTimestamp()});
    return;
  }
  if(c === '/tableflip'){
    const txt = `${localStorage.getItem('nick')||nick} (â•¯Â°â–¡Â°ï¼‰â•¯ï¸µ â”»â”â”»`;
    await addDoc(collection(db,'rooms',room,'messages'), {name:'System', text:txt, color:'#888', time:serverTimestamp()});
    return;
  }
  if(c === '/shrug'){
    const txt = `${localStorage.getItem('nick')||nick} Â¯\\_(ãƒ„)_/Â¯`;
    await addDoc(collection(db,'rooms',room,'messages'), {name:'System', text:txt, color:'#888', time:serverTimestamp()});
    return;
  }

  // /clear: delete messages (ask for confirmation) -> use batched deletes
  // Only admin can clear messages
  if(c === '/clear'){
    if(!isAdmin) {
      await showCustomAlert('Only the room admin can clear messages.', 'ğŸ”’');
      return;
    }
    const confirmed = await showCustomConfirm('Delete all messages in this room?', 'ğŸ—‘ï¸');
    if(!confirmed) return;
    try{
      const msgs = await getDocs(collection(db,'rooms',room,'messages'));
      const refsToDelete = [];
      for(const d of msgs.docs){
        const seenSnap = await getDocs(collection(db,'rooms',room,'messages',d.id,'seen'));
        for(const sd of seenSnap.docs) refsToDelete.push(sd.ref);
        refsToDelete.push(d.ref);
      }
      if(refsToDelete.length) await deleteDocsInBatches(refsToDelete);
    }catch(e){ console.error('/clear error', e); }
    return;
  }

  // /delete or /delet: delete room and messages (ask for confirmation) -> use batched deletes
  // Only admin can delete room
  if(c === '/delete' || c === '/delet'){
    if(!isAdmin) {
      await showCustomAlert('Only the room admin can delete the room.', 'ğŸ”’');
      return;
    }
    const confirmed = await showCustomConfirm('Delete the room and all messages?', 'âš ï¸');
    if(!confirmed) return;
    try{
      // delete typing docs
      const typingDocs = await getDocs(collection(db,'rooms',room,'typing'));
      const refsToDelete = [];
      typingDocs.forEach(t => refsToDelete.push(t.ref));

      // delete messages & their seen subcollections
      const msgs = await getDocs(collection(db,'rooms',room,'messages'));
      for(const d of msgs.docs){
        const seenSnap = await getDocs(collection(db,'rooms',room,'messages',d.id,'seen'));
        for(const sd of seenSnap.docs) refsToDelete.push(sd.ref);
        refsToDelete.push(d.ref);
      }

      // perform deletes in batches
      if(refsToDelete.length) await deleteDocsInBatches(refsToDelete);

      // attempt to delete room doc (last)
      try{ await deleteDoc(doc(db,'rooms',room)); }catch(e){ /* ignore */ }

      // navigate back to home
      if(messagesUnsub) messagesUnsub();
      if(typingUnsub) typingUnsub();
      room = '';
      showHome();
      chat.innerHTML = '';
    }catch(e){ console.error('/delete error', e); }
    return;
  }

  // /giveadmin <username>: Give admin rights to a user
  if(c === '/giveadmin'){
    if(!isAdmin) {
      await showCustomAlert('Only room admins can give admin rights.', 'ğŸ”’');
      return;
    }
    if(!parts[1]) {
      await showCustomAlert('Usage: /giveadmin <username>', 'â„¹ï¸');
      return;
    }
    const targetUser = parts[1].trim();
    const currentUID = localStorage.getItem('session') || '';

    // Get target user's UID
    let targetUID = await getUIDFromUsername(targetUser);

    // Check if target is a guest (guests can't be admins)
    if(targetUser.startsWith('Guest')) {
      await showCustomAlert('Cannot give admin rights to guest accounts.', 'ğŸš«');
      return;
    }

    if(!targetUID) {
      await showCustomAlert(`User "${targetUser}" not found.`, 'ğŸ”');
      return;
    }

    if(targetUID === currentUID) {
      await showCustomAlert('You are already an admin.', 'ğŸ‘‘');
      return;
    }

    try {
      // Update room admins
      const roomRef = doc(db, 'rooms', room);
      const roomSnap = await getDoc(roomRef);
      if(!roomSnap.exists()) {
        await showCustomAlert('Room not found.', 'ğŸ”');
        return;
      }

      const roomData = roomSnap.data();
      let newAdmins;
      if(Array.isArray(roomData.admins)) {
        newAdmins = [...roomData.admins];
      } else if(roomData.admin) {
        newAdmins = [roomData.admin];
      } else {
        newAdmins = [];
      }

      if(!newAdmins.includes(targetUID)) {
        newAdmins.push(targetUID);
        await updateDoc(roomRef, { admins: newAdmins });
        roomAdmins = newAdmins;
        await showCustomAlert(`Admin rights given to ${targetUser}`, 'ğŸ‘‘');
        // Post system message
        await addDoc(collection(db,'rooms',room,'messages'), {
          name:'System',
          text:`${targetUser} has been promoted to admin by ${localStorage.getItem('nick') || nick}`,
          color:'#888',
          time:serverTimestamp()
        });
      } else {
        await showCustomAlert(`${targetUser} is already an admin.`, 'â„¹ï¸');
      }
    } catch(e) {
      console.error('/giveadmin error', e);
      await showCustomAlert('Error giving admin rights: ' + (e.message || String(e)), 'âŒ');
    }
    return;
  }

  // /roles: Open role selector modal
  if(c === '/roles'){
    openRolesModal();
    return;
  }

  // /ban <username>: Ban a user from the room
  if(c === '/ban'){
    if(!isAdmin) {
      await showCustomAlert('Only room admins can ban users.', 'ğŸ”’');
      return;
    }
    if(!parts[1]) {
      await showCustomAlert('Usage: /ban <username>', 'â„¹ï¸');
      return;
    }
    const targetUser = parts[1].trim();
    const currentUID = localStorage.getItem('session') || '';

    // Get target user's UID
    let targetUID = await getUIDFromUsername(targetUser);

    // Check if target is a guest
    if(targetUser.startsWith('Guest')) {
      // For guests, use the guest name as identifier
      targetUID = targetUser;
    }

    if(!targetUID) {
      await showCustomAlert(`User "${targetUser}" not found.`, 'ğŸ”');
      return;
    }

    if(targetUID === currentUID) {
      await showCustomAlert('You cannot ban yourself.', 'ğŸš«');
      return;
    }

    // Check if target is an admin (by UID)
    if(roomAdmins.includes(targetUID)) {
      await showCustomAlert('Cannot ban a room admin.', 'ğŸ”’');
      return;
    }

    try {
      const roomRef = doc(db, 'rooms', room);
      const roomSnap = await getDoc(roomRef);
      if(!roomSnap.exists()) {
        await showCustomAlert('Room not found.', 'ğŸ”');
        return;
      }

      const roomData = roomSnap.data();
      let bannedUsers = roomData.bannedUsers || [];

      if(bannedUsers.includes(targetUID)) {
        await showCustomAlert(`${targetUser} is already banned.`, 'â„¹ï¸');
        return;
      }

      bannedUsers.push(targetUID);
      await updateDoc(roomRef, { bannedUsers });

      await showCustomAlert(`${targetUser} has been banned from this room.`, 'ğŸ”¨');

      // Post system message
      await addDoc(collection(db,'rooms',room,'messages'), {
        name:'System',
        text:`${targetUser} has been banned from the room by ${localStorage.getItem('nick') || currentUID}`,
        color:'#888',
        time:serverTimestamp()
      });

      // Kick the user if they're currently in the room
      await addDoc(collection(db,'rooms',room,'messages'), {
        name:'System',
        text:`You have been banned from ${room}. Goodbye!`,
        color:'#ff4444',
        time:serverTimestamp()
      });

    } catch(e) {
      console.error('/ban error', e);
      await showCustomAlert('Error banning user: ' + (e.message || String(e)), 'âŒ');
    }
    return;
  }

  // /unban <username>: Unban a user from the room
  if(c === '/unban'){
    if(!isAdmin) {
      await showCustomAlert('Only room admins can unban users.', 'ğŸ”’');
      return;
    }
    if(!parts[1]) {
      await showCustomAlert('Usage: /unban <username>', 'â„¹ï¸');
      return;
    }
    const targetUser = parts[1].trim();

    // Get target user's UID
    let targetUID = await getUIDFromUsername(targetUser);

    // Check if target is a guest
    if(targetUser.startsWith('Guest')) {
      targetUID = targetUser;
    }

    if(!targetUID) {
      // If we can't find the user, try the username directly (legacy support)
      targetUID = targetUser;
    }

    try {
      const roomRef = doc(db, 'rooms', room);
      const roomSnap = await getDoc(roomRef);
      if(!roomSnap.exists()) {
        await showCustomAlert('Room not found.', 'ğŸ”');
        return;
      }

      const roomData = roomSnap.data();
      let bannedUsers = roomData.bannedUsers || [];

      if(!bannedUsers.includes(targetUID)) {
        await showCustomAlert(`${targetUser} is not banned.`, 'â„¹ï¸');
        return;
      }

      bannedUsers = bannedUsers.filter(u => u !== targetUID);
      await updateDoc(roomRef, { bannedUsers });

      await showCustomAlert(`${targetUser} has been unbanned from this room.`, 'âœ…');

      // Post system message
      await addDoc(collection(db,'rooms',room,'messages'), {
        name:'System',
        text:`${targetUser} has been unbanned by ${localStorage.getItem('nick') || nick}`,
        color:'#888',
        time:serverTimestamp()
      });

    } catch(e) {
      console.error('/unban error', e);
      await showCustomAlert('Error unbanning user: ' + (e.message || String(e)), 'âŒ');
    }
    return;
  }

  // /banned: List banned users (Admin only)
  if(c === '/banned'){
    if(!isAdmin) {
      await showCustomAlert('Only room admins can view banned users.', 'ğŸ”’');
      return;
    }
    
    try {
      const roomRef = doc(db, 'rooms', room);
      const roomSnap = await getDoc(roomRef);
      if(!roomSnap.exists()) {
        await showCustomAlert('Room not found.', 'ğŸ”');
        return;
      }
      
      const roomData = roomSnap.data();
      const bannedUsers = roomData.bannedUsers || [];
      
      if(bannedUsers.length === 0) {
        await showCustomAlert('No banned users in this room.', 'âœ…');
        return;
      }
      
      await showCustomAlert('Banned users:\n\n' + bannedUsers.join('\n'), 'ğŸš«');
      
    } catch(e) {
      console.error('/banned error', e);
      await showCustomAlert('Error fetching banned users: ' + (e.message || String(e)), 'âŒ');
    }
    return;
  }

  // unknown command -> echo to system
  await addDoc(collection(db,'rooms',room,'messages'), {name:'System', text:`Unknown command: ${cmdText}`, color:'#888', time:serverTimestamp()});
}

/* Enhanced Emoji Picker with Categories */
const emojiCategories = {
  smileys: {
    name: 'ğŸ˜€',
    emojis: ["ğŸ˜€","ğŸ˜ƒ","ğŸ˜„","ğŸ˜","ğŸ˜†","ğŸ˜‚","ğŸ¤£","ğŸ™‚","ğŸ™ƒ","ğŸ˜‰","ğŸ˜Š","ğŸ˜‡","ğŸ¥°","ğŸ˜","ğŸ¤©","ğŸ˜˜","ğŸ˜—","ğŸ˜š","ğŸ˜‹","ğŸ˜›","ğŸ˜œ","ğŸ¤ª","ğŸ˜","ğŸ¤‘","ğŸ¤—","ğŸ¤­","ğŸ¤«","ğŸ¤”","ğŸ¤","ğŸ¤¨","ğŸ˜","ğŸ˜‘","ğŸ˜¶","ğŸ˜","ğŸ˜’","ğŸ™„","ğŸ˜¬","ğŸ¤¥","ğŸ˜Œ","ğŸ˜”","ğŸ˜ª","ğŸ¤¤","ğŸ˜´","ğŸ˜·","ğŸ¤’","ğŸ¤•","ğŸ¤¢","ğŸ¤®","ğŸ¤§","ğŸ¥µ","ğŸ¥¶","ğŸ¥´","ğŸ˜µ","ğŸ¤¯","ğŸ¤ ","ğŸ¥³","ğŸ˜","ğŸ¤“","ğŸ§","ğŸ˜•","ğŸ˜Ÿ","ğŸ™","â˜¹ï¸","ğŸ˜®","ğŸ˜¯","ğŸ˜²","ğŸ˜³","ğŸ¥º","ğŸ˜¦","ğŸ˜§","ğŸ˜¨","ğŸ˜°","ğŸ˜¥","ğŸ˜¢","ğŸ˜­","ğŸ˜±","ğŸ˜–","ğŸ˜£","ğŸ˜","ğŸ˜“","ğŸ˜©","ğŸ˜«","ğŸ¥±","ğŸ˜¤","ğŸ˜¡","ğŸ˜ ","ğŸ¤¬","ğŸ˜ˆ","ğŸ‘¿","ğŸ’€","â˜ ï¸","ğŸ’©","ğŸ¤¡","ğŸ‘¹","ğŸ‘º","ğŸ‘»","ğŸ‘½","ğŸ‘¾","ğŸ¤–","ğŸ˜º","ğŸ˜¸","ğŸ˜¹","ğŸ˜»","ğŸ˜¼","ğŸ˜½","ğŸ™€","ğŸ˜¿","ğŸ˜¾"]
  },
  gestures: {
    name: 'ğŸ‘‹',
    emojis: ["ğŸ‘‹","ğŸ¤š","ğŸ–ï¸","âœ‹","ğŸ––","ğŸ‘Œ","ğŸ¤Œ","ğŸ¤","âœŒï¸","ğŸ¤","ğŸ¤Ÿ","ğŸ¤˜","ğŸ¤™","ğŸ‘ˆ","ğŸ‘‰","ğŸ‘†","ğŸ–•","ğŸ‘‡","â˜ï¸","ğŸ‘","ğŸ‘","âœŠ","ğŸ‘Š","ğŸ¤›","ğŸ¤œ","ğŸ‘","ğŸ™Œ","ğŸ‘","ğŸ¤²","ğŸ¤","ğŸ™","âœï¸","ğŸ’ª","ğŸ¦¾","ğŸ¦µ","ğŸ¦¿","ğŸ¦¶","ğŸ‘£","ğŸ‘‚","ğŸ¦»","ğŸ‘ƒ","ğŸ«€","ğŸ«","ğŸ§ ","ğŸ¦·","ğŸ¦´","ğŸ‘€","ğŸ‘ï¸","ğŸ‘…","ğŸ‘„","ğŸ’‹","ğŸ©¸"]
  },
  hearts: {
    name: 'â¤ï¸',
    emojis: ["â¤ï¸","ğŸ§¡","ğŸ’›","ğŸ’š","ğŸ’™","ğŸ’œ","ğŸ–¤","ğŸ¤","ğŸ¤","â£ï¸","ğŸ’•","ğŸ’","ğŸ’“","ğŸ’—","ğŸ’–","ğŸ’˜","ğŸ’","ğŸ’Ÿ","â˜®ï¸","âœï¸","â˜ªï¸","ğŸ•‰","â˜¸ï¸","âœ¡ï¸","ğŸ”¯","ğŸ•","â˜¯ï¸","â˜¦ï¸","ğŸ›","â›","â™ˆ","â™‰","â™Š","â™‹","â™Œ","â™","â™","â™","â™","â™‘","â™’","â™“","ğŸ†”","âš›ï¸","ğŸ‰‘","â˜¢ï¸","â˜£ï¸","ğŸ“´","ğŸ“³","ğŸˆ¶","ğŸˆš","ğŸˆ¸","ğŸˆº","ğŸˆ·ï¸","âœ´ï¸","ğŸ†š","ğŸ’®","ğŸ‰","ãŠ™ï¸","ãŠ—ï¸","ğŸˆ´","ğŸˆµ","ğŸˆ¹","ğŸˆ²","ğŸ…°ï¸","ğŸ…±ï¸","ğŸ†","ğŸ†‘","ğŸ…¾ï¸","ğŸ†˜","âŒ","â­•","ğŸ›‘","â›”","ğŸ“›","ğŸš«","ğŸ’¯","ğŸ’¢","â™¨ï¸","ğŸš·","ğŸš¯","ğŸš³","ğŸš±","ğŸ”","ğŸ“µ","ğŸš­","â—","â•","â“","â”","â€¼ï¸","â‰ï¸","ğŸ”…","ğŸ”†","ã€½ï¸","âš ï¸","ğŸš¸","ğŸ”±","âšœï¸","ğŸ”°","â™»ï¸","âœ…","ğŸˆ¯","ğŸ’¹","â‡ï¸","âœ³ï¸","â","ğŸŒ","ğŸ’ ","â“‚ï¸","ğŸŒ€","ğŸ’¤","ğŸ§","ğŸš¾","â™¿","ğŸ…¿ï¸","ğŸˆ³","ğŸˆ‚ï¸","ğŸ›‚","ğŸ›ƒ","ğŸ›„","ğŸ›…","ğŸ›—","ğŸš°","ğŸš®","ğŸ¦","ğŸ“¶","ğŸˆ","ğŸ”£","â„¹ï¸","ğŸ”¤","ğŸ”¡","ğŸ” ","ğŸ†–","ğŸ†—","ğŸ†™","ğŸ†’","ğŸ†•","ğŸ†“","0ï¸âƒ£","1ï¸âƒ£","2ï¸âƒ£","3ï¸âƒ£","4ï¸âƒ£","5ï¸âƒ£","6ï¸âƒ£","7ï¸âƒ£","8ï¸âƒ£","9ï¸âƒ£","ğŸ”Ÿ","ğŸ”¢","#ï¸âƒ£","*ï¸âƒ£","âï¸","â–¶ï¸","â¸ï¸","â¯ï¸","â¹ï¸","âºï¸","â­ï¸","â®ï¸","â©","âª","â«","â¬","â—€ï¸","ğŸ”¼","ğŸ”½","â¡ï¸","â¬…ï¸","â¬†ï¸","â¬‡ï¸","â†—ï¸","â†˜ï¸","â†™ï¸","â†–ï¸","â†•ï¸","â†”ï¸","â†ªï¸","â†©ï¸","â¤´ï¸","â¤µï¸","ğŸ”€","ğŸ”","ğŸ”‚","ğŸ”„","ğŸ”ƒ","ğŸµ","ğŸ¶","â•","â–","â—","âœ–ï¸","ğŸ’²","ğŸ’±","â„¢ï¸","Â©ï¸","Â®ï¸","ğŸ‘ï¸â€ğŸ—¨ï¸","ğŸ”š","ğŸ”™","ğŸ”›","ğŸ”","ğŸ”œ","ã€°ï¸","â°","â¿","âœ”ï¸","âŒ","â­•","ğŸ”˜","ğŸ”´","ğŸŸ ","ğŸŸ¡","ğŸŸ¢","ğŸ”µ","ğŸŸ£","âš«","âšª","ğŸŸ¤","ğŸ”º","ğŸ”»","ğŸ”¸","ğŸ”¹","ğŸ”¶","ğŸ”·","ğŸ”³","ğŸ”²","â–ªï¸","â–«ï¸","â—¾","â—½","â—¼ï¸","â—»ï¸","â¬›","â¬œ","ğŸŸ¥","ğŸŸ§","ğŸŸ¨","ğŸŸ©","ğŸŸ¦","ğŸŸª","ğŸŸ«"]
  },
  animals: {
    name: 'ğŸ±',
    emojis: ["ğŸ¶","ğŸ±","ğŸ­","ğŸ¹","ğŸ°","ğŸ¦Š","ğŸ»","ğŸ¼","ğŸ¨","ğŸ¯","ğŸ¦","ğŸ®","ğŸ·","ğŸ½","ğŸ¸","ğŸµ","ğŸ™ˆ","ğŸ™‰","ğŸ™Š","ğŸ’","ğŸ”","ğŸ§","ğŸ¦","ğŸ¤","ğŸ£","ğŸ¥","ğŸ¦†","ğŸ¦…","ğŸ¦‰","ğŸ¦‡","ğŸº","ğŸ—","ğŸ´","ğŸ¦„","ğŸ","ğŸ›","ğŸ¦‹","ğŸŒ","ğŸ","ğŸœ","ğŸ¦Ÿ","ğŸ¦—","ğŸ•·ï¸","ğŸ•¸ï¸","ğŸ¦‚","ğŸ¢","ğŸ","ğŸ¦","ğŸ¦–","ğŸ¦•","ğŸ™","ğŸ¦‘","ğŸ¦","ğŸ¦","ğŸ¦€","ğŸ¡","ğŸ ","ğŸŸ","ğŸ¬","ğŸ³","ğŸ‹","ğŸ¦ˆ","ğŸŠ","ğŸ…","ğŸ†","ğŸ¦“","ğŸ¦","ğŸ¦§","ğŸ˜","ğŸ¦›","ğŸ¦","ğŸª","ğŸ«","ğŸ¦’","ğŸ¦˜","ğŸƒ","ğŸ‚","ğŸ„","ğŸ","ğŸ–","ğŸ","ğŸ‘","ğŸ¦™","ğŸ","ğŸ¦Œ","ğŸ•","ğŸ©","ğŸ¦®","ğŸ•â€ğŸ¦º","ğŸˆ","ğŸˆâ€â¬›","ğŸ“","ğŸ¦ƒ","ğŸ¦š","ğŸ¦œ","ğŸ¦¢","ğŸ¦©","ğŸ•Šï¸","ğŸ‡","ğŸ¦","ğŸ¦¨","ğŸ¦¡","ğŸ¦¦","ğŸ¦¥","ğŸ","ğŸ€","ğŸ¿ï¸","ğŸ¦”"]
  },
  food: {
    name: 'ğŸ',
    emojis: ["ğŸ","ğŸ","ğŸ","ğŸŠ","ğŸ‹","ğŸŒ","ğŸ‰","ğŸ‡","ğŸ“","ğŸˆ","ğŸ’","ğŸ‘","ğŸ","ğŸ¥","ğŸ¥¥","ğŸ¥‘","ğŸ†","ğŸ¥”","ğŸ¥•","ğŸŒ½","ğŸŒ¶ï¸","ğŸ¥’","ğŸ¥¬","ğŸ¥¦","ğŸ§„","ğŸ§…","ğŸ„","ğŸ¥œ","ğŸŒ°","ğŸ","ğŸ¥","ğŸ¥–","ğŸ¥¨","ğŸ¥¯","ğŸ¥","ğŸ§‡","ğŸ§€","ğŸ–","ğŸ—","ğŸ¥©","ğŸ¥“","ğŸ”","ğŸŸ","ğŸ•","ğŸŒ­","ğŸ¥ª","ğŸŒ®","ğŸŒ¯","ğŸ¥™","ğŸ§†","ğŸ¥š","ğŸ³","ğŸ¥˜","ğŸ²","ğŸ¥£","ğŸ¥—","ğŸ¿","ğŸ§ˆ","ğŸ§‚","ğŸ¥«","ğŸ±","ğŸ˜","ğŸ™","ğŸš","ğŸ›","ğŸœ","ğŸ","ğŸ ","ğŸ¢","ğŸ£","ğŸ¤","ğŸ¥","ğŸ¥®","ğŸ¡","ğŸ¥Ÿ","ğŸ¥ ","ğŸ¥¡","ğŸ¦ª","ğŸ¦","ğŸ§","ğŸ¨","ğŸ©","ğŸª","ğŸ‚","ğŸ°","ğŸ§","ğŸ¥§","ğŸ«","ğŸ¬","ğŸ­","ğŸ®","ğŸ¯"]
  },
  activities: {
    name: 'âš½',
    emojis: ["âš½","ğŸ€","ğŸˆ","âš¾","ğŸ¥","ğŸ¾","ğŸ","ğŸ‰","ğŸ¥","ğŸ±","ğŸª€","ğŸ“","ğŸ¸","ğŸ’","ğŸ‘","ğŸ¥","ğŸ","ğŸ¥…","â›³","ğŸª","ğŸ¹","ğŸ£","ğŸ¤¿","ğŸ¥Š","ğŸ¥‹","ğŸ½","ğŸ›¹","ğŸ›·","â›¸ï¸","ğŸ¥Œ","ğŸ¿","â›·ï¸","ğŸ‚","ğŸª‚","ğŸ‹ï¸","ğŸ¤¼","ğŸ¤¸","â›¹ï¸","ğŸ¤º","ğŸ¤¾","ğŸŒï¸","ğŸ‡","ğŸ§˜","ğŸ„","ğŸŠ","ğŸ¤½","ğŸš£","ğŸ§—","ğŸšµ","ğŸš´","ğŸ†","ğŸ¥‡","ğŸ¥ˆ","ğŸ¥‰","ğŸ…","ğŸ–ï¸","ğŸµï¸","ğŸ—ï¸","ğŸ«","ğŸŸï¸","ğŸª","ğŸ¤¹","ğŸ­","ğŸ©°","ğŸ¨","ğŸ¬","ğŸ¤","ğŸ§","ğŸ¼","ğŸ¹","ğŸ¥","ğŸ·","ğŸº","ğŸ¸","ğŸª•","ğŸ»","ğŸ²","â™Ÿï¸","ğŸ¯","ğŸ³","ğŸ®","ğŸ°","ğŸ§©"]
  },
  travel: {
    name: 'ğŸš—',
    emojis: ["ğŸš—","ğŸš•","ğŸš™","ğŸšŒ","ğŸš","ğŸï¸","ğŸš“","ğŸš‘","ğŸš’","ğŸš","ğŸšš","ğŸš›","ğŸšœ","ğŸ¦¯","ğŸ¦½","ğŸ¦¼","ğŸ›´","ğŸš²","ğŸ›µ","ğŸï¸","ğŸ›º","ğŸš¨","ğŸš”","ğŸš","ğŸš˜","ğŸš–","ğŸš¡","ğŸš ","ğŸšŸ","ğŸšƒ","ğŸš‹","ğŸš","ğŸš","ğŸš„","ğŸš…","ğŸšˆ","ğŸš‚","ğŸš†","ğŸš‡","ğŸšŠ","ğŸš‰","âœˆï¸","ğŸ›«","ğŸ›¬","ğŸ›©ï¸","ğŸ’º","ğŸ›°ï¸","ğŸš€","ğŸ›¸","ğŸš","ğŸ›¶","â›µ","ğŸš¤","ğŸ›¥ï¸","ğŸ›³ï¸","â›´ï¸","ğŸš¢","âš“","â›½","ğŸš§","ğŸš¦","ğŸš¥","ğŸš","ğŸ—ºï¸","ğŸ—¿","ğŸ—½","ğŸ—¼","ğŸ°","ğŸ¯","ğŸŸï¸","ğŸ¡","ğŸ¢","ğŸ ","â›²","â›±ï¸","ğŸ–ï¸","ğŸï¸","ğŸœï¸","ğŸŒ‹","â›°ï¸","ğŸ”ï¸","ğŸ—»","ğŸ•ï¸","â›º","ğŸ ","ğŸ¡","ğŸ˜ï¸","ğŸšï¸","ğŸ—ï¸","ğŸ­","ğŸ¢","ğŸ¬","ğŸ£","ğŸ¤","ğŸ¥","ğŸ¦","ğŸ¨","ğŸª","ğŸ«","ğŸ©","ğŸ’’","ğŸ›ï¸","â›ª","ğŸ•Œ","ğŸ•","ğŸ›•","ğŸ•‹","â›©ï¸","ğŸ›¤ï¸","ğŸ›£ï¸","ğŸ—¾","ğŸ‘","ğŸï¸","ğŸŒ…","ğŸŒ„","ğŸŒ ","ğŸ‡","ğŸ†","ğŸŒ‡","ğŸŒ†","ğŸ™ï¸","ğŸŒƒ","ğŸŒŒ","ğŸŒ‰","ğŸŒ"]
  },
  objects: {
    name: 'ğŸ’¡',
    emojis: ["âŒš","ğŸ“±","ğŸ“²","ğŸ’»","âŒ¨ï¸","ğŸ–¥ï¸","ğŸ–¨ï¸","ğŸ–±ï¸","ğŸ–²ï¸","ğŸ•¹ï¸","ğŸ—œï¸","ğŸ’½","ğŸ’¾","ğŸ’¿","ğŸ“€","ğŸ“¼","ğŸ“·","ğŸ“¸","ğŸ“¹","ğŸ¥","ğŸ“½ï¸","ğŸï¸","ğŸ“","â˜ï¸","ğŸ“Ÿ","ğŸ“ ","ğŸ“º","ğŸ“»","ğŸ™ï¸","ğŸšï¸","ğŸ›ï¸","ğŸ§­","â±ï¸","â²ï¸","â°","ğŸ•°ï¸","âŒ›","â³","ğŸ“¡","ğŸ”‹","ğŸ”Œ","ğŸ’¡","ğŸ”¦","ğŸ•¯ï¸","ğŸª”","ğŸ§¯","ğŸ›¢ï¸","ğŸ’¸","ğŸ’µ","ğŸ’´","ğŸ’¶","ğŸ’·","ğŸª™","ğŸ’°","ğŸ’³","ğŸ’","âš–ï¸","ğŸªœ","ğŸ§°","ğŸª›","ğŸ”§","ğŸ”¨","âš’ï¸","ğŸ› ï¸","â›ï¸","ğŸ”©","âš™ï¸","ğŸª¤","ğŸ§±","â›“ï¸","ğŸ§²","ğŸ”«","ğŸ’£","ğŸ§¨","ğŸª“","ğŸ”ª","ğŸ—¡ï¸","âš”ï¸","ğŸ›¡ï¸","ğŸš¬","âš°ï¸","ğŸª¦","âš±ï¸","ğŸº","ğŸ”®","ğŸ“¿","ğŸ§¿","ğŸ’ˆ","âš—ï¸","ğŸ”­","ğŸ”¬","ğŸ•³ï¸","ğŸ©¹","ğŸ©º","ğŸ’Š","ğŸ’‰","ğŸ©¸","ğŸ§¬","ğŸ¦ ","ğŸ§«","ğŸ§ª","ğŸŒ¡ï¸","ğŸ§¹","ğŸª ","ğŸ§º","ğŸ§»","ğŸš½","ğŸš°","ğŸš¿","ğŸ›","ğŸ›€","ğŸ§¼","ğŸª¥","ğŸª’","ğŸ§½","ğŸª£","ğŸ§´","ğŸ›ï¸","ğŸ”‘","ğŸ—ï¸","ğŸšª","ğŸª‘","ğŸ›‹ï¸","ğŸ›ï¸","ğŸ›Œ","ğŸ§¸","ğŸ–¼ï¸","ğŸª","ğŸªŸ","ğŸ›ï¸","ğŸ›’","ğŸ","ğŸˆ","ğŸ","ğŸ€","ğŸª„","ğŸª…","ğŸŠ","ğŸ‰","ğŸ","ğŸ†","ğŸ","ğŸª©","ğŸŒ","ğŸ®","ğŸ‘","ğŸ§§","âœ‰ï¸","ğŸ“©","ğŸ“¨","ğŸ“§","ğŸ’Œ","ğŸ“¥","ğŸ“¤","ğŸ“¦","ğŸ·ï¸","ğŸ“ª","ğŸ“«","ğŸ“¬","ğŸ“­","ğŸ“®","ğŸ“¯","ğŸ“œ","ğŸ“ƒ","ğŸ“„","ğŸ“‘","ğŸ§¾","ğŸ“Š","ğŸ“ˆ","ğŸ“‰","ğŸ—’ï¸","ğŸ—“ï¸","ğŸ“†","ğŸ“…","ğŸ—‘ï¸","ğŸ“‡","ğŸ—ƒï¸","ğŸ—³ï¸","ğŸ—„ï¸","ğŸ“‹","ğŸ“","ğŸ“‚","ğŸ—‚ï¸","ğŸ—ï¸","ğŸ“°","ğŸ““","ğŸ“”","ğŸ“’","ğŸ“•","ğŸ“—","ğŸ“˜","ğŸ“™","ğŸ“š","ğŸ“–","ğŸ”–","ğŸ§·","ğŸ”—","ğŸ“","ğŸ–‡ï¸","ğŸ“","ğŸ“","ğŸ§®","ğŸ“Œ","ğŸ“","âœ‚ï¸","ğŸ–Šï¸","ğŸ–‹ï¸","âœ’ï¸","ğŸ–Œï¸","ğŸ–ï¸","ğŸ“","âœï¸","ğŸ”","ğŸ”","ğŸ”","ğŸ”","ğŸ”’","ğŸ”“"]
  }
};

let currentEmojiCategory = 'smileys';

function buildEmojiPicker(){
  emojiPicker.innerHTML = '';
  
  // Stop propagation on picker to prevent closing when clicking inside
  emojiPicker.onclick = (e) => e.stopPropagation();
  
  // Create tabs container
  const tabsContainer = document.createElement('div');
  tabsContainer.className = 'emoji-tabs';
  tabsContainer.onclick = (e) => e.stopPropagation(); // Prevent closing when clicking tabs
  
  // Create tab buttons for each category
  Object.keys(emojiCategories).forEach(catKey => {
    const cat = emojiCategories[catKey];
    const tabBtn = document.createElement('button');
    tabBtn.className = 'emoji-tab' + (catKey === currentEmojiCategory ? ' active' : '');
    tabBtn.textContent = cat.name;
    tabBtn.onclick = (e) => {
      e.stopPropagation();
      currentEmojiCategory = catKey;
      buildEmojiPicker();
    };
    tabsContainer.appendChild(tabBtn);
  });
  
  emojiPicker.appendChild(tabsContainer);
  
  // Create grid for current category
  const grid = document.createElement('div');
  grid.onclick = (e) => {
    e.stopPropagation();
  };
  
  const currentEmojis = emojiCategories[currentEmojiCategory].emojis;
  currentEmojis.forEach(emoji => {
    const emojiBtn = document.createElement('div');
    emojiBtn.className = 'emoji-item';
    emojiBtn.textContent = emoji;
    emojiBtn.onclick = (e) => {
      e.stopPropagation();
      msg.value += emoji;
      emojiPicker.style.display = 'none';
      emojiPicker.classList.remove('show');
      msg.focus();
    };
    grid.appendChild(emojiBtn);
  });
  
  emojiPicker.appendChild(grid);
  
  // Add search box
  const searchBox = document.createElement('input');
  searchBox.type = 'text';
  searchBox.placeholder = 'Search emojis...';
  searchBox.onclick = (e) => e.stopPropagation(); // Prevent closing when clicking search
  searchBox.oninput = (e) => {
    e.stopPropagation();
    const query = e.target.value.toLowerCase();
    if(query.length === 0) {
      buildEmojiPicker();
      return;
    }
    
    // Search across all categories
    const allEmojis = [];
    Object.values(emojiCategories).forEach(cat => {
      allEmojis.push(...cat.emojis);
    });
    const filtered = allEmojis.filter((emoji, index, self) => self.indexOf(emoji) === index);
    
    grid.innerHTML = '';
    filtered.forEach(emoji => {
      const emojiBtn = document.createElement('div');
      emojiBtn.className = 'emoji-item';
      emojiBtn.textContent = emoji;
      emojiBtn.onclick = (e) => {
        e.stopPropagation();
        msg.value += emoji;
        emojiPicker.style.display = 'none';
        emojiPicker.classList.remove('show');
        msg.focus();
      };
      grid.appendChild(emojiBtn);
    });
  };
  
  emojiPicker.appendChild(searchBox);
}

buildEmojiPicker();

// Enhanced emoji button toggle with positioning
emojiBtn.onclick = (e) => {
  e.stopPropagation();
  const isOpen = emojiPicker.style.display === 'flex';
  
  // Close GIF picker if open
  gifPicker.classList.remove('show');
  
  if(!isOpen) {
    emojiPicker.style.display = 'flex';
    emojiPicker.classList.add('show');
  } else {
    emojiPicker.style.display = 'none';
    emojiPicker.classList.remove('show');
  }
};

// Close emoji picker when clicking outside
document.addEventListener('click', (e) => {
  if(emojiPicker.style.display === 'flex' && !emojiPicker.contains(e.target) && !emojiBtn.contains(e.target)){
    emojiPicker.style.display = 'none';
    emojiPicker.classList.remove('show');
  }
});

/* Enhanced GIF picker functionality - Using Tenor API */
const TENOR_API_KEY = 'LIVDSRZULELA'; // Demo key - get your own at https://tenor.com/gifapi
let gifSearchTimeout;
let currentGifCategory = 'trending';

const gifCategories = {
  trending: { name: 'ğŸ”¥ Trending', query: '' },
  happy: { name: 'ğŸ˜Š Happy', query: 'happy' },
  love: { name: 'â¤ï¸ Love', query: 'love' },
  react: { name: 'âš¡ Reactions', query: 'reaction' }
};

async function searchGifs(query, limit = 20){
  if(!query || !query.trim()){
    // Show featured/trending GIFs if no query
    const res = await fetch(`https://g.tenor.com/v1/featured?key=${TENOR_API_KEY}&limit=${limit}&contentfilter=medium`);
    const data = await res.json();
    return data.results || [];
  }
  
  const res = await fetch(`https://g.tenor.com/v1/search?q=${encodeURIComponent(query)}&key=${TENOR_API_KEY}&limit=${limit}&contentfilter=medium`);
  const data = await res.json();
  return data.results || [];
}

function createGifTabs(){
  // Check if tabs already exist
  if(gifPicker.querySelector('.gif-tabs')) return;
  
  const tabsContainer = document.createElement('div');
  tabsContainer.className = 'gif-tabs';
  tabsContainer.onclick = (e) => e.stopPropagation();
  
  Object.keys(gifCategories).forEach(catKey => {
    const cat = gifCategories[catKey];
    const tabBtn = document.createElement('button');
    tabBtn.className = 'gif-tab' + (catKey === currentGifCategory ? ' active' : '');
    tabBtn.textContent = cat.name;
    tabBtn.onclick = (e) => {
      e.stopPropagation();
      currentGifCategory = catKey;
      updateGifTabs();
      if(catKey === 'trending'){
        searchGifs('', 20).then(displayGifs);
      } else {
        searchGifs(cat.query, 20).then(displayGifs);
      }
    };
    tabsContainer.appendChild(tabBtn);
  });
  
  // Insert tabs before the search input
  gifPicker.insertBefore(tabsContainer, gifSearch);
}

function updateGifTabs(){
  const tabs = gifPicker.querySelectorAll('.gif-tab');
  const catKeys = Object.keys(gifCategories);
  tabs.forEach((tab, index) => {
    if(catKeys[index] === currentGifCategory){
      tab.classList.add('active');
    } else {
      tab.classList.remove('active');
    }
  });
}

function displayGifs(gifs){
  gifResults.innerHTML = '';
  
  if(!gifs || gifs.length === 0){
    gifResults.innerHTML = '<div style="color:var(--muted);text-align:center;padding:30px 20px;font-size:14px;"><div style="font-size:32px;margin-bottom:8px;">ğŸ”</div>No GIFs found</div>';
    return;
  }
  
  gifs.forEach((gif, index) => {
    // Tenor media structure: media[0] contains different formats
    const media = gif.media[0];
    if(!media) return;
    
    const item = document.createElement('div');
    item.className = 'gif-item';
    item.style.animation = `fadeIn 0.3s ease ${index * 0.05}s both`;
    
    const img = document.createElement('img');
    // Use tinygif for preview (smaller, faster loading)
    img.src = media.tinygif?.url || media.gif?.url;
    img.alt = gif.title || 'GIF';
    img.loading = 'lazy';
    
    // Add loading state
    item.style.background = 'rgba(255,255,255,0.03)';
    img.onload = () => {
      item.style.background = 'transparent';
    };
    
    item.appendChild(img);
    // Use full-size gif for sending
    item.onclick = () => sendGifMessage(media.gif?.url || media.tinygif?.url);
    gifResults.appendChild(item);
  });
}

async function sendGifMessage(gifUrl){
  if(!room || !nick) return;

  // Check if user is banned before sending (by UID)
  const currentUID = localStorage.getItem('session') || '';
  try {
    const roomRef = doc(db, 'rooms', room);
    const roomSnap = await getDoc(roomRef);
    if(roomSnap.exists()) {
      const roomData = roomSnap.data();
      const bannedUsers = roomData.bannedUsers || [];
      if(bannedUsers.includes(currentUID)) {
        await showCustomAlert('You are banned from this room.', 'ğŸš«');
        return;
      }
    }
  } catch(e) {
    console.error('Error checking ban status:', e);
  }

  // Close picker
  gifPicker.classList.remove('show');
  gifSearch.value = '';
  currentGifCategory = 'trending';
  updateGifTabs();

  // Send as message with GIF
  const colorToSend = (localStorage.getItem('session') && !localStorage.getItem('session').startsWith('Guest'))
    ? (localStorage.getItem('nickColor') || '#58a6ff')
    : getComputedStyle(document.documentElement).getPropertyValue('--guest-gray').trim();

  await addDoc(collection(db,'rooms',room,'messages'), {
    name: localStorage.getItem('nick') || nick,
    uid: localStorage.getItem('session') || '',
    text: '',
    gif: gifUrl,
    reply: replyTo,
    color: colorToSend,
    time: serverTimestamp()
  }).catch(console.error);

  replyTo = null;
  replyBox.style.display = 'none';

  // Auto-scroll to bottom like text messages
  requestAnimationFrame(() => { scrollChatToBottom(true); updateScrollBottomBtnVisibility(); });
}

// GIF button click
gifBtn.onclick = ()=>{
  const isOpen = gifPicker.classList.contains('show');
  
  // Close emoji picker if open
  emojiPicker.style.display = 'none';
  
  if(!isOpen){
    gifPicker.classList.add('show');
    createGifTabs(); // Ensure tabs exist
    gifSearch.focus();
    // Load trending GIFs initially
    searchGifs('', 20).then(displayGifs);
  } else {
    gifPicker.classList.remove('show');
  }
};

// Stop propagation on GIF picker elements
gifPicker.onclick = (e) => e.stopPropagation();
gifSearch.onclick = (e) => e.stopPropagation();
gifResults.onclick = (e) => e.stopPropagation();

// GIF search input
gifSearch.addEventListener('input', (e)=>{
  e.stopPropagation();
  clearTimeout(gifSearchTimeout);
  gifSearchTimeout = setTimeout(()=>{
    const query = e.target.value.trim();
    if(query){
      // When searching, clear category selection
      currentGifCategory = '';
      updateGifTabs();
      searchGifs(query, 20).then(displayGifs);
    } else {
      currentGifCategory = 'trending';
      updateGifTabs();
      searchGifs('', 20).then(displayGifs);
    }
  }, 400);
});

// Close GIF picker when clicking outside
document.addEventListener('click', (e)=>{
  if(gifPicker.classList.contains('show') && !gifPicker.contains(e.target) && !gifBtn.contains(e.target)){
    gifPicker.classList.remove('show');
    currentGifCategory = 'trending';
  }
});

// Add CSS animation for GIF items
const style = document.createElement('style');
style.textContent = `
  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
  }
`;
document.head.appendChild(style);

/* back button */
back.onclick = ()=>{
  if(messagesUnsub) messagesUnsub();
  if(typingUnsub) typingUnsub();
  // Close online users drawer when leaving room
  closeOnlineUsersDrawer();
  showHome();
  room = '';
  // Clear room tracking for user
  updateUserActivity();
  chat.innerHTML = '';
  typingIndicator.textContent = '';
};

/* lobby size (kept) */
const LOBBY_SIZES = [
  {name:'small', width:'120px'},
  {name:'normal', width:'260px'},
  {name:'large', width:'360px'}
];
let lobbySizeIndex = parseInt(localStorage.getItem('lobbySizeIndex')||'1',10);
applyLobbySize();

lobbySizeBtn.addEventListener('click', ()=> {
  lobbySizeIndex = (lobbySizeIndex + 1) % LOBBY_SIZES.length;
  applyLobbySize();
  localStorage.setItem('lobbySizeIndex', lobbySizeIndex);
});
function applyLobbySize(){
  const s = LOBBY_SIZES[lobbySizeIndex];
  document.documentElement.style.setProperty('--lobby-width', s.width);
  lobbySizeBtn.textContent = s.name[0].toUpperCase();
  if(isMobile) {
    const collapse = (s.name === 'small');
    lobby.classList.toggle('collapsed', collapse);
    chatSidebar.classList.toggle('collapsed', collapse);
  } else {
    lobby.classList.remove('collapsed');
    chatSidebar.classList.remove('collapsed');
  }
}

/* Mobile drawer open/close simplified:
   Keep functions and names but make behavior safe and minimal,
   because mobile logic was removed. This preserves calls from other code.
*/
function openMobileDrawer(){
  // No active mobile UI â€” keep DOM state consistent and hidden.
  if(!mobileOverlay || !mobileDrawer) return;
  mobileOverlay.classList.add('show');
  mobileDrawer.classList.add('show');
  mobileOverlay.style.display = 'block';
  mobileDrawer.style.display = 'block';
  mobileOverlay.setAttribute('aria-hidden','false'); mobileDrawer.setAttribute('aria-hidden','false');
  updateOpenLobbyBtnVisibility();
}
function closeMobileDrawer(){
  if(!mobileOverlay || !mobileDrawer) return;
  mobileDrawer.classList.remove('show');
  mobileOverlay.classList.remove('show');
  const durationMs = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--drawer-duration')) || 200;
  setTimeout(()=>{
    if(!mobileDrawer.classList.contains('show')){
      mobileOverlay.style.display = 'none';
      mobileDrawer.style.display = 'none';
      mobileOverlay.setAttribute('aria-hidden','true'); mobileDrawer.setAttribute('aria-hidden','true');
      updateOpenLobbyBtnVisibility();
    }
  }, durationMs + 20);
}

/* Visibility logic for blue button (mobile) */
function updateOpenLobbyBtnVisibility(){
  const drawerOpen = mobileDrawer && mobileDrawer.classList.contains('show') || false;
  if(!isMobile){
    openLobbyBtn.style.display = 'none'; return;
  }
  const isHomeVisible = home.style.display !== 'none';
  if(isHomeVisible && !drawerOpen) openLobbyBtn.style.display = 'block';
  else openLobbyBtn.style.display = 'none';
}
const origShowHome = showHome;
showHome = function(){ origShowHome(); updateOpenLobbyBtnVisibility(); };
const origShowMain = showMain;
showMain = function(){ origShowMain(); updateOpenLobbyBtnVisibility(); };
const origShowLogin = showLogin;
showLogin = function(){ origShowLogin(); updateOpenLobbyBtnVisibility(); };

/* utility helpers */
function escapeHtml(s){
  if(!s && s !== 0) return '';
  return String(s).replace(/[&<>"']/g, function(m){ return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]); });
}
function escapeAttr(s){ return (s||'').replace(/"/g,'&quot;'); }

function linkify(text){
  const urlRe = /((https?:\/\/|www\.)[\w\-@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([\w\-@:%_\+.~#?&//=]*))/gi;
  return text.replace(urlRe, function(match){
    let url = match;
    if(!/^https?:\/\//i.test(url)) url = 'https://' + url;
    return `<a href="${url}" target="_blank" rel="noopener">${match}</a>`;
  });
}

/* helper to get user color from cache or default */
function getUserColor(name){
  const cached = userCache.get(name);
  if(cached && cached.color) return cached.color;
  return getComputedStyle(document.documentElement).getPropertyValue('--guest-gray').trim();
}

/* Check if a name is already taken by a registered user */
async function isNameTaken(name) {
  if(!name) return false;
  try {
    // Check using the new username mapping
    const uid = await getUIDFromUsername(name);
    return uid !== null;
  } catch(e) {
    console.error('Error checking name:', e);
    return false;
  }
}

// SHA-256 helper (uses SubtleCrypto)
async function sha256(text) {
  const data = new TextEncoder().encode(text);
  const hash = await crypto.subtle.digest('SHA-256', data);
  return [...new Uint8Array(hash)].map(b => b.toString(16).padStart(2, '0')).join('');
}

// Generate unique user ID
function generateUID() {
  if(typeof crypto !== 'undefined' && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  return 'uid_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
}

// Get user UID from username
async function getUIDFromUsername(username) {
  if(!username) return null;
  try {
    const mappingRef = doc(db, 'usernames', username.toLowerCase());
    const snap = await getDoc(mappingRef);
    if(snap.exists()) return snap.data().uid;
    return null;
  } catch(e) {
    console.error('Error getting UID from username:', e);
    return null;
  }
}

// Get username from UID
async function getUsernameFromUID(uid) {
  if(!uid) return null;
  try {
    const userRef = doc(db, 'users', uid);
    const snap = await getDoc(userRef);
    if(snap.exists()) return snap.data().username;
    return null;
  } catch(e) {
    console.error('Error getting username from UID:', e);
    return null;
  }
}

// Cache for UID->username resolution
const uidUsernameCache = new Map();

// Resolve UID to current username (with caching)
async function resolveUIDToUsername(uid) {
  if(!uid) return null;
  if(uid.startsWith('Guest')) return uid;

  if(uidUsernameCache.has(uid)) {
    return uidUsernameCache.get(uid);
  }

  const username = await getUsernameFromUID(uid);
  if(username) {
    uidUsernameCache.set(uid, username);
  }
  return username;
}

// Clear UID cache for a user (when they change username)
function clearUIDCache(uid) {
  uidUsernameCache.delete(uid);
}

loginBtn.addEventListener('click', async (e) => {
  e.preventDefault();
  const username = (loginUser.value || '').trim();
  const password = loginPass.value || '';
  if(!username || !password){ loginMsg.textContent = 'Please enter username and password.'; return; }
  loginMsg.textContent = 'Checking...';
  try {
    // Look up UID from username
    const uid = await getUIDFromUsername(username);
    if(!uid){
      loginMsg.textContent = 'User not found. Please register first.';
      return;
    }

    const userRef = doc(db, 'users', uid);
    const snap = await getDoc(userRef);
    const passHash = await sha256(password);

    if(!snap.exists()){
      loginMsg.textContent = 'User not found. Please register first.';
      return;
    }

    // LOGIN
    const data = snap.data();
    if(data.passwordHash === passHash){
      localStorage.setItem('session', uid);
      localStorage.setItem('nick', data.username || username);
      if (data.color) localStorage.setItem('nickColor', data.color);

      // Update lastSeen on login
      updateUserActivity();

      loginMsg.textContent = 'Login successful âœ…';
      showHome();
    } else {
      loginMsg.textContent = 'Wrong password âŒ';
    }
  } catch (err) {
    console.error(err);
    loginMsg.textContent = 'Error: ' + (err.message || String(err));
  }
});

// Tab switching
const loginTab = document.getElementById('loginTab');
const registerTab = document.getElementById('registerTab');
const loginPanel = document.getElementById('loginPanel');
const registerPanel = document.getElementById('registerPanel');
const regUser = document.getElementById('regUser');
const regPass = document.getElementById('regPass');
const regPassConfirm = document.getElementById('regPassConfirm');

loginTab.addEventListener('click', () => {
  loginTab.classList.add('active');
  registerTab.classList.remove('active');
  loginPanel.classList.add('active');
  registerPanel.classList.remove('active');
  loginMsg.textContent = '';
  loginUser.value = '';
  loginPass.value = '';
});

registerTab.addEventListener('click', () => {
  registerTab.classList.add('active');
  loginTab.classList.remove('active');
  registerPanel.classList.add('active');
  loginPanel.classList.remove('active');
  loginMsg.textContent = 'Choose a username and password to create an account';
  regUser.value = '';
  regPass.value = '';
  regPassConfirm.value = '';
});

registerBtn.addEventListener('click', async (e) => {
  e.preventDefault();
  const username = (regUser.value || '').trim();
  const password = regPass.value || '';
  const confirmPassword = regPassConfirm.value || '';

  if(!username || !password || !confirmPassword){
    loginMsg.textContent = 'Please fill in all fields.';
    return;
  }

  if(password !== confirmPassword) {
    loginMsg.textContent = 'Passwords do not match.';
    return;
  }

  if(password.length < 4) {
    loginMsg.textContent = 'Password must be at least 4 characters.';
    return;
  }

  if(username.startsWith('Guest')) {
    loginMsg.textContent = 'Username cannot start with "Guest".';
    return;
  }

  loginMsg.textContent = 'Registering...';

  try {
    // Check if username is already taken (check lowercase for case-insensitive)
    const existingUID = await getUIDFromUsername(username);
    if(existingUID){
      loginMsg.textContent = 'Username already taken.';
      return;
    }

    const passHash = await sha256(password);
    const uid = generateUID();

    // Create user document by UID
    const userRef = doc(db, 'users', uid);
    await setDoc(userRef, {
      passwordHash: passHash,
      created: serverTimestamp(),
      color: nickColor || '#58a6ff',
      role: '',
      username: username,
      uid: uid
    });

    // Create username -> UID mapping (case-insensitive lookup)
    const usernameMappingRef = doc(db, 'usernames', username.toLowerCase());
    await setDoc(usernameMappingRef, {
      uid: uid,
      username: username,
      created: serverTimestamp()
    });

    localStorage.setItem('session', uid);
    localStorage.setItem('nick', username);
    localStorage.setItem('nickColor', nickColor || '#58a6ff');

    // Update lastSeen on registration
    updateUserActivity();

    loginMsg.textContent = 'Registered and logged in! âœ…';
    showHome();
  } catch (err) {
    console.error(err);
    loginMsg.textContent = 'Error: ' + (err.message || String(err));
  }
});

loginPass.addEventListener('keydown', e => { if (e.key === 'Enter') loginBtn.click(); });
regPass.addEventListener('keydown', e => { if (e.key === 'Enter') registerBtn.click(); });
regPassConfirm.addEventListener('keydown', e => { if (e.key === 'Enter') registerBtn.click(); });

// Demo/guest button with duplicate name check
demoBtn.addEventListener('click', async (e) => {
  e.preventDefault();
  let g = 'Guest' + Math.floor(Math.random()*9000 + 1000);
  
  // Ensure guest name doesn't conflict with registered user
  let attempts = 0;
  while(await isNameTaken(g) && attempts < 10) {
    g = 'Guest' + Math.floor(Math.random()*9000 + 1000);
    attempts++;
  }
  
  if(attempts >= 10) {
    await showCustomAlert('Unable to generate unique guest name. Please try again.', 'ğŸ˜•');
    return;
  }
  
  localStorage.setItem('session', g);
  localStorage.setItem('nick', g);
  const guestColor = getComputedStyle(document.documentElement).getPropertyValue('--guest-gray').trim() || '#9aa0a6';
  localStorage.setItem('nickColor', guestColor);
  showHome();
});

/* Ensure rooms are loaded (real-time) */
setupRoomsListener();

/* ========== Online Users Drawer - SIMPLIFIED ========== */
const ONLINE_THRESHOLD = 5 * 60 * 1000; // 5 minutes in milliseconds
let usersUnsub = null;

// Simple toggle function
function toggleOnlineUsersDrawer() {
  console.log('toggleOnlineUsersDrawer called');
  const drawer = document.getElementById('onlineUsersDrawer');
  const btn = document.getElementById('toggleOnlineUsers');
  console.log('drawer:', drawer, 'btn:', btn);
  if(!drawer) return;
  
  const isCurrentlyOpen = drawer.classList.contains('show');
  console.log('isCurrentlyOpen:', isCurrentlyOpen);
  
  if(isCurrentlyOpen) {
    drawer.classList.remove('show');
    drawer.style.transform = 'translateX(100%)';
    drawer.setAttribute('aria-hidden', 'true');
    btn.style.display = 'block';
  } else {
    drawer.classList.add('show');
    drawer.style.transform = 'translateX(0px)';
    drawer.setAttribute('aria-hidden', 'false');
    btn.style.display = 'none';
    loadOnlineUsersList();
  }
}

// Close function
function closeOnlineUsersDrawer() {
  const drawer = document.getElementById('onlineUsersDrawer');
  const btn = document.getElementById('toggleOnlineUsers');
  if(drawer) {
    drawer.classList.remove('show');
    drawer.style.transform = 'translateX(100%)';
    drawer.setAttribute('aria-hidden', 'true');
  }
  if(btn) btn.style.display = 'block';
}

// Add click listeners
const toggleOnlineUsersBtn = document.getElementById('toggleOnlineUsers');
const closeOnlineUsersBtn = document.getElementById('closeOnlineUsers');

if(toggleOnlineUsersBtn) {
  toggleOnlineUsersBtn.onclick = toggleOnlineUsersDrawer;
}

if(closeOnlineUsersBtn) {
  closeOnlineUsersBtn.onclick = closeOnlineUsersDrawer;
}

// Track user activity and current room
function updateUserActivity() {
  const session = localStorage.getItem('session');
  console.log('updateUserActivity called, session:', session);
  if(!session || session.startsWith('Guest')) return;

  try {
    const userRef = doc(db, 'users', session);
    console.log('Updating user activity for UID:', session);
    updateDoc(userRef, {
      lastSeen: serverTimestamp(),
      currentRoom: room || ''
    }).then(() => {
      console.log('User activity updated successfully');
    }).catch((err) => {
      console.error('Error updating user activity:', err);
    });
  } catch(e) {
    console.error('Exception in updateUserActivity:', e);
  }
}

setInterval(updateUserActivity, 60000);
updateUserActivity();

/* ========== Roles Management ========== */
// To add a new role, copy this template:
// [ROLE_KEY]: { name: 'RoleName', icon: 'ğŸ­', color: '#HEXCODE' }
// Example: wizard: { name: 'Wizard', icon: 'ğŸ”®', color: '#9370DB' }
const ROLES = {
  duck: { name: 'Duck', icon: 'ğŸ¦†', color: '#FFD700' },
  stoner: { name: 'Stoner', icon: 'ğŸŒ¿', color: '#228B22' },
  chad: { name: 'Chad', icon: 'ğŸ”¥', color: '#FF4500' },
  coder: { name: 'Coder', icon: 'ğŸ’»', color: '#00CED1' }
  // Add new roles here - don't forget to also update roles.html!
};

// Current user's selected role
let currentUserRole = null;

// Load user's role from their user doc
async function loadUserRole() {
  const session = localStorage.getItem('session');
  if(!session) return;

  try {
    const userRef = doc(db, 'users', session);
    const userSnap = await getDoc(userRef);
    if(userSnap.exists()) {
      const userData = userSnap.data();
      currentUserRole = userData.role || null;
    }
  } catch(e) {
    console.error('Error loading user role:', e);
  }
}

// Save user's role to their user doc
async function saveUserRole(roleKey) {
  const session = localStorage.getItem('session');
  if(!session) return false;

  try {
    const userRef = doc(db, 'users', session);
    await updateDoc(userRef, { role: roleKey });
    currentUserRole = roleKey;

    // Update user cache immediately
    const cached = userCache.get(session) || {};
    userCache.set(session, { ...cached, role: roleKey });

    // Refresh all existing messages from current user to show new role
    refreshUserRoleBadges(session, roleKey);

    return true;
  } catch(e) {
    console.error('Error saving user role:', e);
    return false;
  }
}

// Refresh role badges on all messages from the current user
function refreshUserRoleBadges(userSession, newRole) {
  const currentNick = localStorage.getItem('nick') || nick;
  const isCurrentUserAdmin = roomAdmins.includes(userSession);
  
  // Find all messages in the chat
  const allMessages = chat.querySelectorAll('.message');
  
  allMessages.forEach(msgEl => {
    const senderEl = msgEl.querySelector('.msg-sender');
    if(!senderEl) return;
    
    // Check if this message is from the current user (by name)
    if(senderEl.textContent !== currentNick) return;
    
    // Remove existing role badges
    const msgContainer = senderEl.parentElement;
    const existingRoleBadges = msgContainer.querySelectorAll('[data-role-badge]');
    existingRoleBadges.forEach(badge => badge.remove());
    
    // Add new role badge if user has a role (admins can have both badges)
    if(newRole && ROLES[newRole]) {
      const roleBadge = document.createElement('span');
      roleBadge.dataset.roleBadge = 'true';
      roleBadge.innerHTML = getRoleBadge(newRole);
      senderEl.insertAdjacentElement('afterend', roleBadge);
    }
  });
}

// Get role badge HTML for a user
function getRoleBadge(roleKey) {
  if(!roleKey || !ROLES[roleKey]) return '';
  const role = ROLES[roleKey];
  return `<span style="background:${role.color};color:#000;font-size:10px;margin-left:6px;padding:2px 8px;border-radius:4px;font-weight:700;text-transform:uppercase;letter-spacing:0.5px;display:inline-flex;align-items:center;gap:3px"><span style="font-size:9px">${role.icon}</span>${role.name}</span>`;
}

// Build and show the roles modal
function openRolesModal() {
  if(!rolesList) return;
  
  rolesList.innerHTML = '';
  
  // Add "No role" option first
  const noRoleEl = document.createElement('div');
  noRoleEl.style.cssText = 'display:flex;align-items:center;gap:12px;padding:12px;border-radius:8px;cursor:pointer;transition:background 150ms;margin-bottom:8px;border:1px solid transparent';
  noRoleEl.innerHTML = `
    <div style="width:40px;height:40px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:20px;background:rgba(255,255,255,0.05)">ğŸš«</div>
    <div style="flex:1">
      <div style="font-weight:600;color:var(--muted)">No Role</div>
      <div style="font-size:12px;color:var(--muted)">Remove your role</div>
    </div>
    ${!currentUserRole ? '<span style="color:#3fb950;font-size:14px">âœ“</span>' : ''}
  `;
  
  noRoleEl.addEventListener('mouseenter', () => {
    noRoleEl.style.background = 'rgba(255,255,255,0.03)';
    noRoleEl.style.borderColor = 'rgba(255,255,255,0.1)';
  });
  noRoleEl.addEventListener('mouseleave', () => {
    noRoleEl.style.background = 'transparent';
    noRoleEl.style.borderColor = 'transparent';
  });
  
  noRoleEl.addEventListener('click', async () => {
    const success = await saveUserRole(null);
    if(success) {
      openRolesModal();
      await addDoc(collection(db,'rooms',room,'messages'), {
        name:'System', 
        text:`${localStorage.getItem('nick') || nick} removed their role`, 
        color:'#888', 
        time:serverTimestamp()
      });
    }
  });
  
  rolesList.appendChild(noRoleEl);
  
  Object.entries(ROLES).forEach(([key, role]) => {
    const roleEl = document.createElement('div');
    roleEl.style.cssText = 'display:flex;align-items:center;gap:12px;padding:12px;border-radius:8px;cursor:pointer;transition:background 150ms;margin-bottom:8px;border:1px solid transparent';
    roleEl.innerHTML = `
      <div style="width:40px;height:40px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:20px;background:${role.color}20">${role.icon}</div>
      <div style="flex:1">
        <div style="font-weight:600;color:${role.color}">${role.name}</div>
        <div style="font-size:12px;color:var(--muted)">${role.icon} Role</div>
      </div>
      ${currentUserRole === key ? '<span style="color:#3fb950;font-size:14px">âœ“</span>' : ''}
    `;
    
    roleEl.addEventListener('mouseenter', () => {
      roleEl.style.background = 'rgba(255,255,255,0.03)';
      roleEl.style.borderColor = role.color + '40';
    });
    roleEl.addEventListener('mouseleave', () => {
      roleEl.style.background = 'transparent';
      roleEl.style.borderColor = 'transparent';
    });
    
    roleEl.addEventListener('click', async () => {
      const success = await saveUserRole(key);
      if(success) {
        // Update checkmarks
        openRolesModal();
        // Show confirmation
        await addDoc(collection(db,'rooms',room,'messages'), {
          name:'System', 
          text:`${localStorage.getItem('nick') || nick} is now a ${role.icon} ${role.name}`, 
          color:'#888', 
          time:serverTimestamp()
        });
      }
    });
    
    rolesList.appendChild(roleEl);
  });
  
  rolesModal.style.display = 'block';
}

// Close roles modal
function closeRolesModal() {
  if(rolesModal) rolesModal.style.display = 'none';
}

// Roles modal event listeners
if(closeRoles) {
  closeRoles.addEventListener('click', closeRolesModal);
}

if(viewAllRoles) {
  viewAllRoles.addEventListener('click', async () => {
    const allRolesText = Object.values(ROLES).map(r => `${r.icon} ${r.name}`).join(' â€¢ ');
    await showCustomAlert('Available Roles:\n\n' + allRolesText, 'ğŸ­');
  });
}

// Load user role on login
loadUserRole();

// Load online users
async function loadOnlineUsersList() {
  console.log('loadOnlineUsersList called');
  const listEl = document.getElementById('onlineUsersList');
  if(!listEl) {
    console.log('listEl not found');
    return;
  }

  listEl.innerHTML = '<div style="color:var(--muted);font-size:13px;text-align:center;padding:20px">Loading...</div>';

  try {
    console.log('Fetching users from Firestore...');
    const usersCol = collection(db, 'users');
    const snapshot = await getDocs(usersCol);
    console.log('Fetched', snapshot.size, 'users');

    const now = Date.now();
    const users = [];

    snapshot.forEach(doc => {
      const userData = doc.data();
      const uid = doc.id;

      // Skip guests (they don't have UIDs, they use session with Guest prefix)
      if(uid.startsWith('Guest')) return;

      let isOnline = false;
      if(userData.lastSeen) {
        const lastSeenTime = userData.lastSeen.toMillis ? userData.lastSeen.toMillis() : userData.lastSeen;
        isOnline = (now - lastSeenTime) < ONLINE_THRESHOLD;
      }

      users.push({
        uid: uid,
        username: userData.username || 'Unknown',
        color: userData.color || '#58a6ff',
        isOnline: isOnline,
        currentRoom: userData.currentRoom || null
      });
    });

    console.log('Processed', users.length, 'registered users');

    users.sort((a, b) => {
      if(a.isOnline && !b.isOnline) return -1;
      if(!a.isOnline && b.isOnline) return 1;
      return a.username.localeCompare(b.username);
    });

    listEl.innerHTML = '';

    if(users.length === 0) {
      listEl.innerHTML = '<div style="color:var(--muted);font-size:13px;text-align:center;padding:20px">No registered users found</div>';
      return;
    }

    users.forEach(user => {
      const userEl = document.createElement('div');
      userEl.dataset.uid = user.uid;
      userEl.dataset.username = user.username;
      userEl.className = 'online-user';
      userEl.style.cssText = 'display:flex;align-items:center;gap:8px;padding:8px;border-radius:8px;margin-bottom:4px;cursor:pointer;transition:background 150ms';
      
       const roomInfo = user.currentRoom && user.isOnline ? `<span style="color:var(--accent);font-size:11px;margin-left:6px;flex-shrink:0">#${user.currentRoom}</span>` : '';
       
       userEl.innerHTML = `
         <div style="width:32px;height:32px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:14px;color:#000;background:${user.color}">${user.username[0]}</div>
         <div style="flex:1;min-width:0">
           <div style="display:flex;align-items:center;gap:0;flex-wrap:nowrap">
             <span style="font-size:13px;font-weight:500;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;flex-shrink:0">${user.username}</span>
             ${roomInfo}
           </div>
           <div style="font-size:11px;color:var(--muted);display:flex;align-items:center;gap:4px">
             <span style="width:8px;height:8px;border-radius:50%;background:${user.isOnline ? '#3fb950' : 'var(--muted)'}"></span>
             ${user.isOnline ? 'Online' : 'Offline'}
           </div>
         </div>
         <button class="dm-action-btn" data-uid="${user.uid}" data-username="${user.username}" data-color="${user.color}" title="Send DM">âœ‰ï¸</button>
       `;
      
      userEl.onclick = (e) => {
        // Don't show profile if clicking on DM button
        if(e.target.classList.contains('dm-action-btn')) return;
        // Hide any existing profile card first
        profileCard.classList.remove('show');
        profileCard.setAttribute('aria-hidden', 'true');
        // Show profile card on click
        const joined = null;
        showProfileCardFor(user.username, user.color, joined, userEl);
      };
      userEl.onmouseenter = () => {
        userEl.style.background = 'rgba(255,255,255,0.03)';
      };
      userEl.onmouseleave = () => {
        userEl.style.background = 'transparent';
        setTimeout(() => {
          if(!userEl.matches(':hover') && !profileCard.matches(':hover')) {
            profileCard.classList.remove('show');
            profileCard.setAttribute('aria-hidden', 'true');
          }
        }, 200);
      };
      listEl.appendChild(userEl);
    });
  } catch(err) {
    console.error('Error loading online users:', err);
    listEl.innerHTML = '<div style="color:#ff6b6b;font-size:13px;text-align:center;padding:20px">Error loading users</div>';
  }
}

function setupUsersListener() {
  if(usersUnsub) usersUnsub();
  
  try {
    const usersCol = collection(db, 'users');
    usersUnsub = onSnapshot(usersCol, () => {
      const drawer = document.getElementById('onlineUsersDrawer');
      if(drawer && drawer.classList.contains('show')) {
        loadOnlineUsersList();
      }
    });
  } catch(e) {
    console.error('users listener error', e);
  }
}

// Refresh online users list every 30 seconds when drawer is open
setInterval(() => {
  const drawer = document.getElementById('onlineUsersDrawer');
  if(drawer && drawer.classList.contains('show')) {
    loadOnlineUsersList();
  }
}, 30000);

setupUsersListener();

/* ========== New global keyboard handling ========== */
/* Open How To only on bare '?' (no Alt/AltGraph/Ctrl/Meta) and close on Escape */
document.addEventListener('keydown', (e) => {
  // If user is focused in an input/textarea, don't hijack (except when they press Esc)
  const active = document.activeElement;
  const isTypingField = active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable);

  if(e.key === '?' && !e.altKey && !e.ctrlKey && !e.metaKey){
    // don't open when focus is in input (user probably meant to type '?')
    if(isTypingField) return;
    e.preventDefault();
    // open external how.html in a new tab
    window.open('how.html','_blank');
  }

  if(e.key === 'Escape'){
    // close menus
    if(howMenu.classList.contains('show')) { howMenu.classList.remove('show'); howMenu.setAttribute('aria-hidden','true'); }
    if(settingsMenu.classList.contains('show')) { settingsMenu.classList.remove('show'); settingsMenu.setAttribute('aria-hidden','true'); }
    if(profileCard.classList.contains('show')) { profileCard.classList.remove('show'); profileCard.setAttribute('aria-hidden','true'); }
    if(contextMenu.style.display === 'block') { contextMenu.style.display = 'none'; contextMenu.setAttribute('aria-hidden','true'); }
    if(changeUsernameModal.style.display === 'block') { changeUsernameModal.style.display = 'none'; }
    if(changePasswordModal.style.display === 'block') { changePasswordModal.style.display = 'none'; }
    if(editDescriptionModal.style.display === 'block') { editDescriptionModal.style.display = 'none'; }
    if(createRoomModal.style.display === 'block') { createRoomModal.style.display = 'none'; }
    if(onlineUsersDrawer.classList.contains('show')) { onlineUsersDrawer.classList.remove('show'); onlineUsersDrawer.setAttribute('aria-hidden','true'); }
    if(rolesModal && rolesModal.style.display === 'block') { rolesModal.style.display = 'none'; }
    if(superAdminModal && superAdminModal.style.display === 'block') { superAdminModal.style.display = 'none'; }
    if(setSuperAdminModal && setSuperAdminModal.style.display === 'block') { setSuperAdminModal.style.display = 'none'; }
  }
});

let isSuperAdmin = false;
let allRoomsData = [];
let allUsersData = [];

// Super Admin functionality
const superAdminModal = document.getElementById('superAdminModal');
const setSuperAdminModal = document.getElementById('setSuperAdminModal');
const settingsSuperAdmin = document.getElementById('settingsSuperAdmin');

async function loadStats() {
  try {
    const roomsSnap = await getDocs(collection(db, 'rooms'));
    const usersSnap = await getDocs(collection(db, 'users'));
    const now = Date.now();
    let onlineCount = 0;
    usersSnap.forEach(doc => {
      const data = doc.data();
      if(data.lastSeen) {
        const lastSeen = data.lastSeen.toMillis ? data.lastSeen.toMillis() : data.lastSeen;
        if(now - lastSeen < ONLINE_THRESHOLD) onlineCount++;
      }
    });
    document.getElementById('statRooms').textContent = roomsSnap.size;
    document.getElementById('statUsers').textContent = usersSnap.size;
    document.getElementById('statOnline').textContent = onlineCount;
    return { rooms: roomsSnap.size, users: usersSnap.size, online: onlineCount };
  } catch(e) {
    console.error('Error loading stats:', e);
    return { rooms: 0, users: 0, online: 0 };
  }
}

async function loadRoomsForSuperAdmin(container, filter = '') {
  container.innerHTML = '<div style="color:var(--muted);font-size:13px;text-align:center;padding:30px">Loading...</div>';
  try {
    const snapshot = await getDocs(collection(db, 'rooms'));
    allRoomsData = [];
    snapshot.forEach(doc => {
      allRoomsData.push({ id: doc.id, ...doc.data() });
    });
    renderRooms(container, filter);
  } catch(err) {
    container.innerHTML = '<div style="color:#ff6b6b;font-size:13px;text-align:center;padding:30px">Error loading rooms</div>';
  }
}

function renderRooms(container, filter = '') {
  const filtered = allRoomsData.filter(r => r.id.toLowerCase().includes(filter.toLowerCase()));
  container.innerHTML = '';
  if(filtered.length === 0) {
    container.innerHTML = '<div style="color:var(--muted);font-size:13px;text-align:center;padding:30px">' + (filter ? 'No rooms match your search' : 'No rooms found') + '</div>';
    return;
  }
  filtered.forEach(room => {
    const roomEl = document.createElement('div');
    roomEl.style.cssText = 'display:flex;align-items:center;gap:12px;padding:12px;border-radius:8px;margin-bottom:8px;background:var(--card);transition:background 150ms';
    roomEl.innerHTML = `
      <div style="width:40px;height:40px;border-radius:10px;background:linear-gradient(135deg,var(--accent),#845ef7);display:flex;align-items:center;justify-content:center;font-size:18px">#</div>
      <div style="flex:1;min-width:0">
        <div style="font-weight:600;font-size:14px">${room.id}</div>
        <div style="font-size:12px;color:var(--muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${room.description || 'No description'}</div>
        ${room.password ? '<span style="font-size:10px;color:#ffd43b;margin-top:2px;display:block">ğŸ”’ Password protected</span>' : ''}
      </div>
      <button class="delete-room-btn" style="padding:8px 14px;border-radius:8px;border:0;background:rgba(255,107,107,0.15);color:#ff6b6b;font-weight:600;cursor:pointer;font-size:12px;transition:all 150ms">Delete</button>
    `;
    roomEl.onmouseenter = () => roomEl.style.background = 'rgba(255,255,255,0.05)';
    roomEl.onmouseleave = () => roomEl.style.background = 'var(--card)';
    roomEl.querySelector('.delete-room-btn').onclick = async (e) => {
      e.stopPropagation();
      if(await showCustomConfirm(`Delete room "${room.id}"? This cannot be undone.`, 'ğŸ’¥')) {
        await deleteDoc(doc(db, 'rooms', room.id));
        allRoomsData = allRoomsData.filter(r => r.id !== room.id);
        renderRooms(container, filter);
        loadStats();
      }
    };
    container.appendChild(roomEl);
  });
}

async function loadUsersForSuperAdmin(container, filter = '') {
  container.innerHTML = '<div style="color:var(--muted);font-size:13px;text-align:center;padding:30px">Loading...</div>';
  try {
    const snapshot = await getDocs(collection(db, 'users'));
    allUsersData = [];
    const now = Date.now();
    snapshot.forEach(doc => {
      const data = doc.data();
      const isOnline = data.lastSeen ? (now - (data.lastSeen.toMillis ? data.lastSeen.toMillis() : data.lastSeen) < ONLINE_THRESHOLD) : false;
      allUsersData.push({ id: doc.id, ...data, isOnline });
    });
    renderUsers(container, filter);
  } catch(err) {
    container.innerHTML = '<div style="color:#ff6b6b;font-size:13px;text-align:center;padding:30px">Error loading users</div>';
  }
}

function renderUsers(container, filter = '') {
  const filtered = allUsersData.filter(u => 
    (u.username || '').toLowerCase().includes(filter.toLowerCase()) || 
    u.id.toLowerCase().includes(filter.toLowerCase())
  );
  container.innerHTML = '';
  if(filtered.length === 0) {
    container.innerHTML = '<div style="color:var(--muted);font-size:13px;text-align:center;padding:30px">' + (filter ? 'No users match your search' : 'No users found') + '</div>';
    return;
  }
  filtered.forEach(user => {
    const userEl = document.createElement('div');
    userEl.style.cssText = 'display:flex;align-items:center;gap:12px;padding:12px;border-radius:8px;margin-bottom:8px;background:var(--card);transition:background 150ms';
    userEl.innerHTML = `
      <div style="position:relative">
        <div style="width:40px;height:40px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;color:#000;font-size:15px;background:${user.color || '#58a6ff'}">${(user.username || '?')[0]}</div>
        <div style="position:absolute;bottom:-2px;right:-2px;width:14px;height:14px;border-radius:50%;background:${user.isOnline ? '#3fb950' : 'var(--muted)'};border:2px solid var(--panel)"></div>
      </div>
      <div style="flex:1;min-width:0">
        <div style="font-weight:600;font-size:14px;display:flex;align-items:center;gap:6px">
          ${user.username || 'Unknown'}
          ${user.isOnline ? '<span style="font-size:10px;background:#3fb950;color:#000;padding:1px 6px;border-radius:4px;font-weight:600">Online</span>' : ''}
        </div>
        <div style="font-size:11px;color:var(--muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${user.id}</div>
      </div>
      <button class="delete-user-btn" style="padding:8px 14px;border-radius:8px;border:0;background:rgba(255,107,107,0.15);color:#ff6b6b;font-weight:600;cursor:pointer;font-size:12px;transition:all 150ms">Delete</button>
    `;
    userEl.onmouseenter = () => userEl.style.background = 'rgba(255,255,255,0.05)';
    userEl.onmouseleave = () => userEl.style.background = 'var(--card)';
    userEl.querySelector('.delete-user-btn').onclick = async (e) => {
      e.stopPropagation();
      if(await showCustomConfirm(`Delete user "${user.username}"? This will permanently remove the account.`, 'âš ï¸')) {
        await deleteDoc(doc(db, 'users', user.id));
        allUsersData = allUsersData.filter(u => u.id !== user.id);
        renderUsers(container, filter);
        loadStats();
      }
    };
    container.appendChild(userEl);
  });
}

if(settingsSuperAdmin) {
  settingsSuperAdmin.addEventListener('click', async () => {
    settingsMenu.classList.remove('show');
    const hasSetup = await checkSuperAdminSetup();
    if(!hasSetup) {
      setSuperAdminModal.style.display = 'block';
    } else {
      superAdminModal.style.display = 'block';
      document.getElementById('superAdminAuth').style.display = 'flex';
      document.getElementById('superAdminPanel').style.display = 'none';
      document.getElementById('superAdminPassword').value = '';
      document.getElementById('superAdminMsg').textContent = '';
    }
  });
}

if(document.getElementById('cancelSetSuperAdmin')) {
  document.getElementById('cancelSetSuperAdmin').addEventListener('click', () => {
    setSuperAdminModal.style.display = 'none';
  });
}

if(document.getElementById('confirmSetSuperAdmin')) {
  document.getElementById('confirmSetSuperAdmin').addEventListener('click', async () => {
    const pass = document.getElementById('newSuperAdminPassword').value;
    const confirm = document.getElementById('confirmSuperAdminPassword').value;
    const msg = document.getElementById('setSuperAdminMsg');
    if(!pass || pass.length < 4) {
      msg.textContent = 'Password must be at least 4 characters';
      msg.style.color = '#ff6b6b';
      return;
    }
    if(pass !== confirm) {
      msg.textContent = 'Passwords do not match';
      msg.style.color = '#ff6b6b';
      return;
    }
    try {
      await setDoc(doc(db, 'superadmin', 'config'), { password: pass, created: serverTimestamp() });
      setSuperAdminModal.style.display = 'none';
      superAdminModal.style.display = 'block';
    } catch(e) {
      msg.textContent = 'Error saving password';
      msg.style.color = '#ff6b6b';
    }
  });
}

if(document.getElementById('cancelSuperAdmin')) {
  document.getElementById('cancelSuperAdmin').addEventListener('click', () => {
    superAdminModal.style.display = 'none';
  });
}

if(document.getElementById('closeSuperAdmin')) {
  document.getElementById('closeSuperAdmin').addEventListener('click', () => {
    superAdminModal.style.display = 'none';
    isSuperAdmin = false;
  });
}

if(document.getElementById('authSuperAdmin')) {
  document.getElementById('authSuperAdmin').addEventListener('click', async () => {
    const password = document.getElementById('superAdminPassword').value;
    const msg = document.getElementById('superAdminMsg');
    msg.textContent = 'Verifying...';
    msg.style.color = 'var(--muted)';
    const valid = await verifySuperAdminPassword(password);
    if(valid) {
      isSuperAdmin = true;
      msg.textContent = '';
      document.getElementById('superAdminAuth').style.display = 'none';
      document.getElementById('superAdminPanel').style.display = 'block';
      await loadStats();
      loadRoomsForSuperAdmin(document.getElementById('superAdminRoomsList'));
      loadUsersForSuperAdmin(document.getElementById('superAdminUsersList'));
    } else {
      msg.textContent = 'Invalid password';
      msg.style.color = '#ff6b6b';
    }
  });
}

if(document.getElementById('superAdminRoomsTab')) {
  document.getElementById('superAdminRoomsTab').addEventListener('click', function() {
    this.style.background = 'var(--card)';
    this.style.color = 'var(--text)';
    document.getElementById('superAdminUsersTab').style.background = 'transparent';
    document.getElementById('superAdminUsersTab').style.color = 'var(--muted)';
    document.getElementById('superAdminRoomsList').style.display = 'block';
    document.getElementById('superAdminUsersList').style.display = 'none';
  });
}

if(document.getElementById('superAdminUsersTab')) {
  document.getElementById('superAdminUsersTab').addEventListener('click', function() {
    this.style.background = 'var(--card)';
    this.style.color = 'var(--text)';
    document.getElementById('superAdminRoomsTab').style.background = 'transparent';
    document.getElementById('superAdminRoomsTab').style.color = 'var(--muted)';
    document.getElementById('superAdminUsersList').style.display = 'block';
    document.getElementById('superAdminRoomsList').style.display = 'none';
  });
}

const superAdminSearch = document.getElementById('superAdminSearch');
if(superAdminSearch) {
  superAdminSearch.addEventListener('input', (e) => {
    const activeTab = document.getElementById('superAdminUsersList').style.display !== 'none' ? 'users' : 'rooms';
    if(activeTab === 'rooms') {
      renderRooms(document.getElementById('superAdminRoomsList'), e.target.value);
    } else {
      renderUsers(document.getElementById('superAdminUsersList'), e.target.value);
    }
  });
}

if(document.getElementById('superAdminDeleteAllRooms')) {
  document.getElementById('superAdminDeleteAllRooms').addEventListener('click', async () => {
    if(await showCustomConfirm('Delete ALL rooms? This will permanently delete every room!', 'ğŸ’¥')) {
      const batch = writeBatch(db);
      allRoomsData.forEach(room => {
        batch.delete(doc(db, 'rooms', room.id));
      });
      await batch.commit();
      allRoomsData = [];
      renderRooms(document.getElementById('superAdminRoomsList'), '');
      loadStats();
    }
  });
}

// Mark user offline when leaving page
async function markUserOffline() {
  const session = localStorage.getItem('session');
  if(session && !session.startsWith('Guest')) {
    try {
      await updateDoc(doc(db, 'users', session), { isOnline: false, lastSeen: serverTimestamp() });
    } catch(e) {}
  }
}

async function markUserOnline() {
  const session = localStorage.getItem('session');
  if(session && !session.startsWith('Guest')) {
    try {
      await updateDoc(doc(db, 'users', session), { isOnline: true, lastSeen: serverTimestamp() });
    } catch(e) {}
  }
}

document.addEventListener('visibilitychange', async () => {
  if(document.visibilityState === 'hidden') {
    markUserOffline();
  } else if(document.visibilityState === 'visible') {
    markUserOnline();
  }
});

window.addEventListener('beforeunload', () => {
  markUserOffline();
});

// Also mark online when user interacts with the page
document.addEventListener('click', markUserOnline, { once: true });
document.addEventListener('keydown', markUserOnline, { once: true });
document.addEventListener('mousemove', markUserOnline, { once: true });

/* ========== DIRECT MESSAGES (DM) ========== */
let currentDmPartner = null;
let dmUnsub = null;
let dmConversations = [];

const dmPanel = document.getElementById('dmPanel');
const dmChatPanel = document.getElementById('dmChatPanel');
const dmConversationsEl = document.getElementById('dmConversations');
const dmMessagesEl = document.getElementById('dmMessages');
const dmInput = document.getElementById('dmInput');
const dmEmptyState = document.getElementById('dmEmptyState');

async function getOrCreateDmConversation(otherUid) {
  const session = localStorage.getItem('session');
  if(!session || session.startsWith('Guest')) return null;
  
  const participants = [session, otherUid].sort();
  const convId = participants.join('_');
  
  const convRef = doc(db, 'dm_conversations', convId);
  const convSnap = await getDoc(convRef);
  
  if(!convSnap.exists()) {
    const otherUserSnap = await getDoc(doc(db, 'users', otherUid));
    const otherUserData = otherUserSnap.data();
    await setDoc(convRef, {
      participants: participants,
      participantData: {
        [session]: { username: localStorage.getItem('nick'), color: localStorage.getItem('nickColor') },
        [otherUid]: { username: otherUserData?.username || 'Unknown', color: otherUserData?.color || '#58a6ff' }
      },
      lastMessage: null,
      lastMessageTime: null,
      unreadCount: { [session]: 0, [otherUid]: 0 },
      created: serverTimestamp()
    });
  }
  
  return convId;
}

async function loadDmConversations() {
  const session = localStorage.getItem('session');
  if(!session || session.startsWith('Guest')) return;
  
  dmConversationsEl.innerHTML = '';
  dmConversations = [];
  
  try {
    const convsQuery = query(collection(db, 'dm_conversations'), where('participants', 'array-contains', session));
    const snapshot = await getDocs(convsQuery);
    
    const convs = [];
    snapshot.forEach(doc => {
      convs.push({ id: doc.id, ...doc.data() });
    });
    
    convs.sort((a, b) => {
      if(!a.lastMessageTime) return 1;
      if(!b.lastMessageTime) return -1;
      return b.lastMessageTime.toMillis() - a.lastMessageTime.toMillis();
    });
    
    dmConversations = convs;
    
    if(convs.length === 0) {
      dmEmptyState.style.display = 'block';
      return;
    }
    
    dmEmptyState.style.display = 'none';
    
    convs.forEach(conv => {
      const otherUid = conv.participants.find(p => p !== session);
      const otherData = conv.participantData?.[otherUid] || {};
      const isOnline = conv.participantData?.[otherUid]?.isOnline || false;
      const lastMsg = conv.lastMessage || 'No messages yet';
      const time = conv.lastMessageTime ? new Date(conv.lastMessageTime.toMillis()).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}) : '';
      const unread = conv.unreadCount?.[session] || 0;
      
      const convEl = document.createElement('div');
      convEl.className = 'dm-conv';
      convEl.innerHTML = `
        <div class="dm-conv-avatar" style="background:${otherData.color || '#58a6ff'}">${(otherData.username || '?')[0]}</div>
        <div class="dm-conv-info">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div class="dm-conv-name">${otherData.username || 'Unknown'}</div>
            <div class="dm-conv-time">${time}</div>
          </div>
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div class="dm-conv-preview">${lastMsg}</div>
            ${unread > 0 ? `<div class="dm-conv-unread">${unread}</div>` : ''}
          </div>
        </div>
      `;
      convEl.onclick = () => openDmChat(conv.id, otherUid, otherData);
      convEl.onmouseenter = () => convEl.style.background = 'rgba(255,255,255,0.05)';
      convEl.onmouseleave = () => convEl.style.background = 'transparent';
      dmConversationsEl.appendChild(convEl);
    });
  } catch(err) {
    console.error('Error loading DM conversations:', err);
  }
}

async function openDmChat(convId, otherUid, otherData) {
  currentDmPartner = { uid: otherUid, ...otherData };
  
  // Hide lobby and DM panel, show full-screen DM
  home.style.display = 'none';
  main.style.display = 'none';
  dmPanel.style.transform = 'translateX(-100%)';
  dmChatPanel.style.display = 'flex';
  
  document.getElementById('dmChatUsername').textContent = otherData.username || 'Unknown';
  document.getElementById('dmChatStatus').textContent = 'Loading...';
  
  // Load other user status
  try {
    const userSnap = await getDoc(doc(db, 'users', otherUid));
    const userData = userSnap.data();
    const isOnline = userData?.lastSeen ? (Date.now() - (userData.lastSeen.toMillis ? userData.lastSeen.toMillis() : userData.lastSeen) < 300000) : false;
    document.getElementById('dmChatStatus').textContent = isOnline ? 'Online' : 'Offline';
    document.getElementById('dmChatStatus').style.color = isOnline ? '#3fb950' : 'var(--muted)';
  } catch(e) {
    document.getElementById('dmChatStatus').textContent = 'Unknown';
  }
    
  // Clear and load messages
  dmMessagesEl.innerHTML = '<div style="text-align:center;color:var(--muted);font-size:14px;padding:40px">Loading messages...</div>';
    
  if(dmUnsub) dmUnsub();
  
  // Fetch messages without orderBy (to avoid needing an index)
  const messagesCol = collection(db, 'dms');
  const messagesQuery = query(messagesCol, where('conversationId', '==', convId));
  dmUnsub = onSnapshot(messagesQuery, async (snapshot) => {
    dmMessagesEl.innerHTML = '';
    
    if(snapshot.empty) {
      dmMessagesEl.innerHTML = '<div style="text-align:center;color:var(--muted);font-size:14px;padding:40px">No messages yet. Say hi!</div>';
      return;
    }
    
    // Sort messages by time in JavaScript
    const messages = [];
    snapshot.forEach(doc => {
      messages.push({ id: doc.id, ...doc.data() });
    });
    messages.sort((a, b) => {
      const timeA = a.time?.toMillis?.() || 0;
      const timeB = b.time?.toMillis?.() || 0;
      return timeA - timeB;
    });
    
    const session = localStorage.getItem('session');
    messages.forEach(msg => {
      const isOwn = msg.from === session;
      const time = msg.time?.toMillis ? new Date(msg.time.toMillis()).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}) : '';
      
      const msgEl = document.createElement('div');
      msgEl.style.cssText = `max-width:75%;padding:12px 16px;border-radius:18px;font-size:14px;line-height:1.5;${isOwn ? 'align-self:flex-end;background:var(--accent);color:#000;margin-left:auto;border-bottom-right-radius:4px' : 'align-self:flex-start;background:var(--card);border-bottom-left-radius:4px'}`.replace(/\s+/g, ' ').trim();
      msgEl.innerHTML = `
        <div style="word-wrap:break-word">${escapeHtml(msg.text)}</div>
        <div style="font-size:11px;opacity:0.6;margin-top:6px;text-align:${isOwn ? 'right' : 'left'}">${time}</div>
      `;
      dmMessagesEl.appendChild(msgEl);
    });
    
    dmMessagesEl.scrollTop = dmMessagesEl.scrollHeight;
  });
  
  // Mark as read
  try {
    const convRef = doc(db, 'dm_conversations', convId);
    const convSnap = await getDoc(convRef);
    if(convSnap.exists()) {
      const unread = convSnap.data().unreadCount || {};
      unread[localStorage.getItem('session')] = 0;
      await updateDoc(convRef, { unreadCount: unread });
    }
  } catch(e) {}
  
  dmInput.value = '';
  dmInput.focus();
}

function closeDmChat() {
  dmChatPanel.style.display = 'none';
  currentDmPartner = null;
  if(dmUnsub) dmUnsub();
  showHome();
}

async function sendDm() {
  if(!currentDmPartner || !dmInput.value.trim()) return;
  
  const session = localStorage.getItem('session');
  if(!session || session.startsWith('Guest')) {
    await showCustomAlert('Please sign in to send direct messages.', 'ğŸ’¬');
    return;
  }
  
  const text = dmInput.value.trim();
  lastOwnMessage = text;
  console.log('DM sent, saved lastOwnMessage:', lastOwnMessage);
  const convId = [session, currentDmPartner.uid].sort().join('_');
  const participants = [session, currentDmPartner.uid].sort();
  
  // /clear: delete all DM messages
  if(text === '/clear') {
    const confirmed = await showCustomConfirm('Delete all messages in this conversation?', 'ğŸ—‘ï¸');
    if(!confirmed) {
      dmInput.value = '';
      return;
    }
    try{
      const msgs = await getDocs(collection(db, 'dms'));
      const refsToDelete = [];
      msgs.docs.forEach(d => {
        if(d.data().conversationId === convId) {
          refsToDelete.push(d.ref);
        }
      });
      if(refsToDelete.length) await deleteDocsInBatches(refsToDelete);
      dmInput.value = '';
    } catch(e) {
      console.error('/clear error', e);
      await showCustomAlert('Failed to clear messages.', 'âŒ');
    }
    return;
  }
  
  try {
    await addDoc(collection(db, 'dms'), {
      conversationId: convId,
      from: session,
      to: currentDmPartner.uid,
      text: text,
      time: serverTimestamp()
    });
    
    // Update conversation
    const convRef = doc(db, 'dm_conversations', convId);
    const convData = (await getDoc(convRef)).data();
    await updateDoc(convRef, {
      lastMessage: text,
      lastMessageTime: serverTimestamp(),
      [`unreadCount.${currentDmPartner.uid}`]: (convData?.unreadCount?.[currentDmPartner.uid] || 0) + 1
    });
    
    dmInput.value = '';
  } catch(err) {
    console.error('Error sending DM:', err);
    await showCustomAlert('Failed to send message.', 'âŒ');
  }
}

// Add DM button click handler using event delegation
document.addEventListener('click', async (e) => {
  if(e.target.classList.contains('dm-action-btn')) {
    e.stopPropagation();
    const uid = e.target.dataset.uid;
    const username = e.target.dataset.username;
    const color = e.target.dataset.color;
    console.log('DM button clicked for', username);
    const convId = await getOrCreateDmConversation(uid);
    if(convId) {
      dmPanel.style.transform = 'translateX(-100%)';
      await new Promise(r => setTimeout(r, 300));
      openDmChat(convId, uid, { username, color });
    }
  }
});

// Back from DM handler
document.getElementById('backFromDm')?.addEventListener('click', () => {
  closeDmChat();
});

// DM panel close handler
document.getElementById('closeDmPanel')?.addEventListener('click', () => {
  dmPanel.style.transform = 'translateX(-100%)';
  dmChatPanel.style.display = 'none';
});

// Start DM button
document.getElementById('startDmBtn')?.addEventListener('click', async () => {
  const session = localStorage.getItem('session');
  if(!session || session.startsWith('Guest')) {
    await showCustomAlert('Please sign in to send direct messages.', 'ğŸ’¬');
    return;
  }
  openDMPanel();
});

// Add DM button to profile card
const profileCardOriginalHTML = document.getElementById('profileCard')?.innerHTML;

// DM Panel tabs
document.getElementById('dmConversationsTab')?.addEventListener('click', function() {
  this.classList.add('active');
  document.getElementById('dmAllUsersTab').classList.remove('active');
  document.getElementById('dmConversations').style.display = 'block';
  document.getElementById('dmAllUsers').style.display = 'none';
  document.getElementById('dmEmptyState').style.display = loadDmConversations() ? 'none' : 'block';
});

document.getElementById('dmAllUsersTab')?.addEventListener('click', async function() {
  this.classList.add('active');
  document.getElementById('dmConversationsTab').classList.remove('active');
  document.getElementById('dmConversations').style.display = 'none';
  document.getElementById('dmAllUsers').style.display = 'block';
  document.getElementById('dmEmptyState').style.display = 'none';
  await loadAllUsersForDM();
});

// Load all users for DM selector
async function loadAllUsersForDM() {
  const container = document.getElementById('dmAllUsers');
  if(!container) return;
  
  container.innerHTML = '<div style="text-align:center;color:var(--muted);font-size:13px;padding:30px">Loading users...</div>';
  
  const session = localStorage.getItem('session');
  if(!session || session.startsWith('Guest')) {
    container.innerHTML = '<div style="text-align:center;color:var(--muted);font-size:13px;padding:30px">Please sign in to message users.</div>';
    return;
  }
  
  try {
    const usersCol = collection(db, 'users');
    const snapshot = await getDocs(usersCol);
    
    const users = [];
    snapshot.forEach(doc => {
      if(doc.id !== session && !doc.id.startsWith('Guest')) {
        users.push({ uid: doc.id, ...doc.data() });
      }
    });
    
    users.sort((a, b) => (a.username || '').localeCompare(b.username || ''));
    
    if(users.length === 0) {
      container.innerHTML = '<div style="text-align:center;color:var(--muted);font-size:13px;padding:30px">No users found.</div>';
      return;
    }
    
    container.innerHTML = '';
    
    users.forEach(user => {
      const userEl = document.createElement('div');
      userEl.className = 'online-user';
      userEl.innerHTML = `
        <div style="width:36px;height:36px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;color:#000;font-size:14px;background:${user.color || '#58a6ff'}">${(user.username || '?')[0]}</div>
        <div style="flex:1;min-width:0">
          <div style="font-size:13px;font-weight:500;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${user.username || 'Unknown'}</div>
        </div>
        <button class="dm-action-btn" data-uid="${user.uid}" data-username="${user.username}" data-color="${user.color || '#58a6ff'}" title="Send DM">âœ‰ï¸</button>
      `;
      container.appendChild(userEl);
    });
  } catch(err) {
    console.error('Error loading users:', err);
    container.innerHTML = '<div style="text-align:center;color:#ff6b6b;font-size:13px;padding:30px">Error loading users.</div>';
  }
}

document.addEventListener('click', async (e) => {
  if(e.target.closest('#profileCard') && !e.target.closest('button') && !e.target.closest('input') && !e.target.closest('textarea')) {
    await new Promise(r => setTimeout(r, 50));
    const card = document.getElementById('profileCard');
    const name = document.getElementById('profileName')?.textContent;
    if(card && name && !card.querySelector('.dm-from-profile')) {
      const cardContent = card.querySelector('.profile-row:last-child');
      if(cardContent) {
        const dmBtn = document.createElement('button');
        dmBtn.className = 'dm-from-profile';
        dmBtn.textContent = 'ğŸ’¬ Send Message';
        dmBtn.style.cssText = 'width:100%;padding:10px;border-radius:8px;border:0;background:var(--accent);color:#000;font-weight:600;cursor:pointer;margin-top:10px';
        dmBtn.onclick = async () => {
          const session = localStorage.getItem('session');
          if(!session || session.startsWith('Guest')) {
            await showCustomAlert('Please sign in to send direct messages.', 'ğŸ’¬');
            return;
          }
          
          const usersQuery = query(collection(db, 'users'), where('username', '==', name));
          const snapshot = await getDocs(usersQuery);
          if(snapshot.empty) return;
          
          const uid = snapshot.docs[0].id;
          const userData = snapshot.docs[0].data();
          const convId = await getOrCreateDmConversation(uid);
          
          if(convId) {
            card.classList.remove('show');
            card.setAttribute('aria-hidden', 'true');
            dmPanel.style.transform = 'translateX(-100%)';
            await new Promise(r => setTimeout(r, 300));
            openDmChat(convId, uid, { username: userData.username, color: userData.color });
          }
        };
        cardContent.parentElement.insertBefore(dmBtn, cardContent);
      }
    }
  }
});

// Panel toggle
document.getElementById('closeDmPanel')?.addEventListener('click', () => {
  dmPanel.style.transform = 'translateX(-100%)';
  dmChatPanel.style.display = 'none';
});

// Show conversations tab when opening DM panel
async function openDMPanel() {
  dmPanel.style.transform = 'translateX(0)';
  document.getElementById('dmConversationsTab').classList.add('active');
  document.getElementById('dmAllUsersTab').classList.remove('active');
  document.getElementById('dmConversations').style.display = 'block';
  document.getElementById('dmAllUsers').style.display = 'none';
  loadDmConversations();
}

document.getElementById('backToDmList')?.addEventListener('click', () => {
  dmChatPanel.style.transform = 'translateX(-100%)';
  if(dmUnsub) dmUnsub();
  currentDmPartner = null;
});

// Add DM button to home/chat header
const headerDMBtn = document.createElement('button');
headerDMBtn.id = 'openDMPanel';
headerDMBtn.textContent = 'ğŸ’¬';
headerDMBtn.title = 'Direct Messages';
document.getElementById('topRightControls')?.appendChild(headerDMBtn);

document.getElementById('openDMPanel')?.addEventListener('click', () => {
  openDMPanel();
});

// Send on Enter
dmInput?.addEventListener('keydown', (e) => {
  if(e.key === 'ArrowUp' && dmInput.value === '') {
    e.preventDefault();
    console.log('DM ArrowUp pressed, lastOwnMessage:', lastOwnMessage);
    dmInput.value = lastOwnMessage;
    return;
  }
  if(e.key === 'Enter') sendDm();
});

document.getElementById('dmSendBtn')?.addEventListener('click', sendDm);

// DM button initialization (handled by event delegation in document click handler)

// Check for unread DMs periodically
setInterval(async () => {
  const session = localStorage.getItem('session');
  if(!session || session.startsWith('Guest')) return;
  
  try {
    const convsQuery = query(collection(db, 'dm_conversations'), where('participants', 'array-contains', session));
    const snapshot = await getDocs(convsQuery);
    let totalUnread = 0;
    snapshot.forEach(doc => {
      totalUnread += doc.data().unreadCount?.[session] || 0;
    });
    
    const dmBtn = document.getElementById('openDMPanel');
    if(dmBtn) {
      dmBtn.innerHTML = totalUnread > 0 ? `ğŸ’¬<span style="position:absolute;top:-2px;right:-2px;background:#ff6b6b;color:#000;font-size:9px;padding:2px 5px;border-radius:10px;font-weight:700">${totalUnread}</span>` : 'ğŸ’¬';
      dmBtn.style.position = 'relative';
    }
  } catch(e) {}
}, 30000);
</script>
</body>
</html>
